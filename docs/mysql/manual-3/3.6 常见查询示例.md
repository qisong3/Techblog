---
title: 3.6 常见查询示例
date: 2020-11-17
last-update: 2020-11-17
tags:
 - MySQL
keywords:
 - MySQL
 - manual
 - Tutorial
---

这里列举一些常用的示例，解决一般的查询问题

有些示例使用表商店为特定的贸易商(交易商)保存每个商品(商品编号)的价格。假设每个交易者对每条商品有一个固定的价格，那么(article, dealer)就是记录的主键。

进入mysql命令行并且选中一个数据库

```sql
shell> mysql your-database-name
```

使用如下语句创建以及填充示例表

```sql
CREATE TABLE shop (
    article INT UNSIGNED  DEFAULT '0000' NOT NULL,
    dealer  CHAR(20)      DEFAULT ''     NOT NULL,
    price   DECIMAL(16,2) DEFAULT '0.00' NOT NULL,
    PRIMARY KEY(article, dealer));
INSERT INTO shop VALUES
    (1,'A',3.45),(1,'B',3.99),(2,'A',10.99),(3,'B',1.45),
    (3,'C',1.69),(3,'D',1.25),(4,'D',19.95);
```
执行如上操作以后，表中应当由如下内容：
```sql
SELECT * FROM shop ORDER BY article;

+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|       1 | A      |  3.45 |
|       1 | B      |  3.99 |
|       2 | A      | 10.99 |
|       3 | B      |  1.45 |
|       3 | C      |  1.69 |
|       3 | D      |  1.25 |
|       4 | D      | 19.95 |
+---------+--------+-------+
```

## 3.6.1 行最大值
售价最高的是哪个商品？
```sql
SELECT MAX(article) AS article FROM shop;

+---------+
| article |
+---------+
|       4 |
+---------+
```
## 3.6.2 包含某一列的最大值的行
任务:找到最昂贵的物品的数量，经销商和价格。
这很容易通过子查询完成
```sql
SELECT article, dealer, price
FROM   shop
WHERE  price=(SELECT MAX(price) FROM shop);

+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0004 | D      | 19.95 |
+---------+--------+-------+
```
其他解决方案是使用左联接或按价格降序对所有行排序，并使用特定于mysql的LIMIT子句只获取第一行
```SQL
SELECT s1.article, s1.dealer, s1.price
FROM shop s1
LEFT JOIN shop s2 ON s1.price < s2.price
WHERE s2.article IS NULL;

SELECT article, dealer, price
FROM shop
ORDER BY price DESC
LIMIT 1;
```
::: tip
如果最贵的商品有不止一个，那么也将只显示一个
:::

::: tip 译者注
这里对上面的第一个查询进行一个说明，乍一看可能有点抽象，题目要求找到价格最高的商品。

这里使用商品表和自身做了一个左连接，注意左连接是保留左表的全部数据，和右表中符合条件的做笛卡尔乘积。
如果是`SELECT * FROM shop s1
      LEFT JOIN shop s2 ON s1.price < s2.price`
那么比较容易理解，挨个取出s1表中的数据，并逐个拼接表s2中符合条件的数据，结果如下图所示：
![左连接全查询](/images/mysql-manual/left_join_all.png)

这里是取出连接表的全部数据，注意最后一行，由于左表中最大的一行在右表中没有匹配项，故s2表中的各个字段都为NULL。

其实上面那个查询就是取的这个最后一行，也就是这个表中的最大值了。
:::

## 3.6.3 每组中的最大值
任务：找到每个商品的最高报价
```sql
SELECT article, MAX(price) AS price
FROM   shop
GROUP BY article
ORDER BY article;

+---------+-------+
| article | price |
+---------+-------+
|    0001 |  3.99 |
|    0002 | 10.99 |
|    0003 |  1.69 |
|    0004 | 19.95 |
+---------+-------+
```
## 3.6.4 包含组最大值的行
任务:对于每一件物品，找出价格最高的经销商或经销商。
```sql
SELECT article, dealer, price
FROM   shop s1
WHERE  price=(SELECT MAX(s2.price)
              FROM shop s2
              WHERE s1.article = s2.article)
ORDER BY article;

+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0001 | B      |  3.99 |
|    0002 | A      | 10.99 |
|    0003 | C      |  1.69 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
```
这个查询用到了相关联的子查询，效率较低。(关于关联子查询可以参照 [Section 13.2.11.7, “Correlated Subqueries](https://dev.mysql.com/doc/refman/8.0/en/correlated-subqueries.html))。其他的解决方案有：
- 使用不相关联的子查询进行内联查询
```sql
SELECT s1.article, dealer, s1.price
FROM shop s1
JOIN (
  SELECT article, MAX(price) AS price
  FROM shop
  GROUP BY article) AS s2
  ON s1.article = s2.article AND s1.price = s2.price
ORDER BY article;
```
- 使用左连接
```sql
SELECT s1.article, s1.dealer, s1.price
FROM shop s1
LEFT JOIN shop s2 ON s1.article = s2.article AND s1.price < s2.price
WHERE s2.article IS NULL
ORDER BY s1.article;
```
左连接的原理在上一节已经特别说明过了，这里再重复一下：左连接的左表中s1.price是最大值时，右表中是没有对应更高的价钱，因此s2.article是NULL。
具体可参考[Section 13.2.10.2, “JOIN Clause”](https://dev.mysql.com/doc/refman/8.0/en/join.html)
- 使用窗口函数Common table expression
```sql
WITH s1 AS (
   SELECT article, dealer, price,
          RANK() OVER (PARTITION BY article
                           ORDER BY price DESC
                      ) AS `Rank`
     FROM shop
)
SELECT article, dealer, price
  FROM s1
  WHERE `Rank` = 1
ORDER BY article;
```
::: tip 译者注
这里Common table expression和临时表类似，又有不同，会在后面的章节中介绍
:::
