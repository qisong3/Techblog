---
title: 8.2 优化SQL表达式--8.2.1 优化SELECT表达式
date: 2020-12-01
last-update: 2020-11-01
tags:
 - MySQL
keywords:
 - MySQL
 - manual
 - 优化
---


数据库应用程序的核心逻辑是通过SQL语句执行的，无论是直接通过解释器发出还是通过API在后台提交。本节中的调优指南有助于加速所有类型的MySQL应用程序。这些指导方针涵盖了读和写数据的SQL操作、SQL操作的一般幕后开销以及特定场景中使用的操作(如数据库监视)。

查询以SELECT语句的形式执行数据库中的所有查找操作。调优这些语句是最重要的任务，无论是为动态web页面实现亚秒级的响应时间，还是减少生成大量夜间报告的时间。

除了SELECT语句之外，查询的调优技术也适用于诸 CREATE TABLE...AS SELECT, INSERT INTO...SELECT以及DELETE语句中的WHERE表达式。这些语句还有其他性能考虑因素，因为它们将写操作与面向读的查询操作结合在一起。

NDB集群支持一种下推式的优化通过将连接查询发到各个NDB节点中，以便可以分布式同步执行查询。更多详情请参阅[Conditions for NDB pushdown joins. ](https://dev.mysql.com/doc/refman/8.0/en/mysql-cluster-options-variables.html#ndb_join_pushdown-conditions)

优化查询的主要考虑事项是:

- 将一个SELECT ... WHERE查询变快，第一件事是查看是否可以添加索引。在WHERE子句中使用的列上设置索引，以加速结果的计算、筛选和最终检索。为了避免浪费磁盘空间，构造一个小的索引集来加速应用程序中使用的许多相关查询。
  
  索引对于使用联接和外键等功能引用不同表的查询尤为重要。可以使用[EXPLAIN](https://dev.mysql.com/doc/refman/8.0/en/explain.html)语句确定SELECT使用哪些索引。参照[Section 8.3.1, “How MySQL Uses Indexes” and Section 8.8.1, “Optimizing Queries with EXPLAIN”.](https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html)

- 隔离和调优查询的任何部分，例如函数调用，这会花费过多的时间。根据查询的结构，可以对结果集中的每一行调用一次函数，甚至对表中的每一行调用一次函数，这会极大地提高效率。
- 最小化查询中的全表扫描次数，特别是对于大表。
- 通过定期使用[ANALYZE TABLE](https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html)语句使表统计信息保持最新状态，因此优化器具有构造有效执行计划所需的信息。
- 了解每个表的存储引擎特定的调整技术，索引技术和配置参数。InnoDB和MyISAM都有一套指导原则来实现和保持查询的高性能。详情参考[Section 8.5.6, “Optimizing InnoDB Queries”](https://dev.mysql.com/doc/refman/8.0/en/optimizing-innodb-queries.html)和[SECTION 8.6.1 Optimizing MyISAM Queries](https://dev.mysql.com/doc/refman/8.0/en/optimizing-queries-myisam.html)
- 可以优化InnoDB表的单查询事务，参考[ Section 8.5.3, “Optimizing InnoDB Read-Only Transactions”](https://dev.mysql.com/doc/refman/8.0/en/innodb-performance-ro-txn.html)
- 避免以难以理解的方式转换查询，特别是在优化器自动执行某些相同转换的情况下。
- 如果性能问题不能通过基本准则之一轻松解决，那么通过阅读EXPLAIN计划并调整索引、WHERE子句、join子句等来研究特定查询的内部细节。(当你达到一定的专业水平时，阅读EXPLAIN计划可能是你解决每个问题的第一步)
- 调整MySQL用于缓存的内存区域的大小和属性。由于InnoDB缓冲池、MyISAM键缓存和MySQL查询缓存的有效使用，重复查询运行速度更快，因为结果是在第二次和后续时间从内存中检索的。
- 即使是使用缓存内存区域快速运行的查询，您仍然可以进一步优化，使它们需要更少的缓存内存，从而使您的应用程序更具可伸缩性。可伸缩性意味着您的应用程序可以处理更多的并发用户、更大的请求等等，而不会经历性能的大幅下降。
- 处理锁问题，在锁问题中，查询的速度可能会受到同时访问表的其他会话的影响。

## 8.2.1.1 WHERE语句优化
本节讨论可用于处理WHERE子句的优化。这些示例使用SELECT语句，但是DELETE和UPDATE语句中的WHERE子句也适用相同的优化。
::: tip
由于MySQL的优化在持续进行，这里并没有记录MySQL执行的所有优化。
:::
您可能会试图重写查询以提高算术运算速度，同时牺牲可读性。因为MySQL会自动进行类似的优化，所以通常可以避免这种工作，并使查询以一种更容易理解和维护的形式存在。下面是MySQL执行的一些优化:
- 去除不必要的括号
```sql
   ((a AND b) AND c OR (((a AND b) AND (c AND d))))
-> (a AND b AND c) OR (a AND b AND c AND d)
```
- 常数折叠
```sql
   (a<b AND b=c) AND a=5
-> b>5 AND b=c AND a=5
```
- 常数条件删除
```sql
   (b>=5 AND b=5) OR (b=6 AND 5=5) OR (b=7 AND 5=6)
-> b=5 OR b=6
```
在MySQL 8.0.14及以后版本中，这个过程发生在准备阶段，而不是优化阶段，这有助于简化连接。参考[Section 8.2.1.9, “Outer Join Optimization”](https://dev.mysql.com/doc/refman/8.0/en/outer-join-optimization.html)
- 索引使用的常量表达式只计算一次。
- 从MySQL 8.0.16开始，数值类型的列与常量值的比较将被检查、合并或删除无效或过期的值。参考[ Section 8.2.1.14, “Constant-Folding Optimization”](https://dev.mysql.com/doc/refman/8.0/en/constant-folding-optimization.html)
- 没有WHERE的单个表上的COUNT(*)直接从MyISAM表和内存表的表信息中检索。当只对一个表使用时，对于任何NOT NULL表达式也可以这样做。
- 对无效常量表达式的早期检测。MySQL能够迅速发现一些SELECT语句是无效的并且不返回任何数据。
- 如果不使用GROUP BY或聚合函数(COUNT()、MIN()等)，则使用WHERE合并HAVING。
- 对于在JOIN操作中的表，WHERE操作将构造得更简单以便速度更快，同时也尽早跳过行。
- 在查询中首先读取所有常量表，然后再读取其他表。常量表是以下任何一种
  * 空表或只有一行的表
  * 与主键或唯一索引上的WHERE子句一起使用的表，其中所有索引部分都与常量表达式进行比较，并定义为NOT NULL。
    下面所有的表都用作常量表
    ```sql
    SELECT * FROM t WHERE primary_key=1;
    SELECT * FROM t1,t2
        WHERE t1.primary_key=1 AND t2.primary_key=t1.id;
    ```
- 连接表的最佳连接组合是通过尝试所有可能找到的。如果ORDER BY和GROUP BY子句中的所有列都来自同一个表，则在连接时首选该表。
- 如果存在ORDER BY子句和不同的GROUP BY子句，或者ORDER BY或GROUP BY包含联接队列中第一个表以外的表中的列，则创建一个临时表。
- 如果使用SQL_SMALL_RESULT修饰符，MySQL将使用内存中的临时表。
- 每个表索引都会被查询，并且使用最好的索引，除非优化器认为使用全表扫描更有效。曾经，根据最佳索引是否跨越表的30%使用扫描，但是现在一个固定的百分比不再决定使用索引还是扫描。现在，优化器更加复杂，其估计基于其他因素，例如表大小，行数和I/O块大小。
- 在某些情况下，MySQL甚至可以不查阅数据文件就从索引中读取行。如果索引中使用的所有列都是数值型的，则仅使用索引树来解析查询。
- 在输出每一行之前，将跳过那些与HAVING子句不匹配的行。                                 

一些非常快的查询示例
```sql
SELECT COUNT(*) FROM tbl_name;

SELECT MIN(key_part1),MAX(key_part1) FROM tbl_name;

SELECT MAX(key_part2) FROM tbl_name
  WHERE key_part1=constant;

SELECT ... FROM tbl_name
  ORDER BY key_part1,key_part2,... LIMIT 10;

SELECT ... FROM tbl_name
  ORDER BY key_part1 DESC, key_part2 DESC, ... LIMIT 10;
```
MySQL只使用索引树解析以下查询，假设索引列是数字的
```sql
SELECT key_part1,key_part2 FROM tbl_name WHERE key_part1=val;

SELECT COUNT(*) FROM tbl_name
  WHERE key_part1=val1 AND key_part2=val2;

SELECT key_part2 FROM tbl_name GROUP BY key_part1;
```
下面的查询使用索引以排序顺序检索行，而不需要单独的排序通道
```sql
SELECT ... FROM tbl_name
  ORDER BY key_part1,key_part2,... ;

SELECT ... FROM tbl_name
  ORDER BY key_part1 DESC, key_part2 DESC, ... ;
```
## 8.2.1.2 范围优化
范围访问方法使用单个索引检索包含在一个或多个索引值区间内的表行子集。它可以用于单部分或多部分索引。下面几节描述优化器使用范围访问的条件。

### 单值索引的范围查询
                       
对于单值，可以方便地用WHERE子句中的对应条件表示索引值区间，表示为范围条件，而不是区间。

单值索引范围条件的定义如下
- 对于BTREE和HASH索引，使用=, <=>, IN(), IS NULL,或者IS NOT NULL操作符与常量比较
- 此外，对于BTREE索引，使用 >, <, >=, <=, BETWEEN, !=,<> 操作符,或者不带通配符前缀的LIKE与常量比较
- 对于所有类型的索引，使用OR或者AND进行条件范围查询

这里的**常量**包含如下情况：
- 查询字符串中的常量
- 同一个JOIN中的[const](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_const)或者[system](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_system)表中的列
- 不关联的子查询的结果
- 完全由前面类型的子表达式组成的任何表达式

下面是一些在WHERE语句中使用范围查询的例子
```sql
SELECT * FROM t1
  WHERE key_col > 1
  AND key_col < 10;

SELECT * FROM t1
  WHERE key_col = 1
  OR key_col IN (15,18,20);

SELECT * FROM t1
  WHERE key_col LIKE 'ab%'
  OR key_col BETWEEN 'bar' AND 'foo';
```          

在优化器常量传播阶段，一些非常量值可能被转换为常量。

MySQL尝试在WHERE语句中为每个可能的索引抽取范围条件。在提取过程中，将删除不能用于构造范围条件的条件，组合产生重叠范围的条件，并删除产生空范围的条件。

看下面的表达式，key1是索引列，nokey没有索引:
```sql
SELECT * FROM t1 WHERE
  (key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
  (key1 < 'bar' AND nonkey = 4) OR
  (key1 < 'uux' AND key1 > 'z');
```
key1抽取的过程如下：
1  从原始的WHERE语句开始
```sql
(key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
(key1 < 'bar' AND nonkey = 4) OR
(key1 < 'uux' AND key1 > 'z')
```
2  首先剔除nokey = 4和key1 LIKE '%b'因为它们不能用于范围扫描。正确的去除方式是将这个语句变成TRUE，所以在范围扫描过程中我们不会错过任何匹配行。将相应语句替换为TRUE字段。
```sql
(key1 < 'abc' AND (key1 LIKE 'abcde%' OR TRUE)) OR
(key1 < 'bar' AND TRUE) OR
(key1 < 'uux' AND key1 > 'z')
```
3  总为真的条件转为TRUE，总为假的条件转为FALSE
- (key1 LIKE 'abcde%' OR TRUE) 总为真
- (key1 < 'uux' AND key1 > 'z') 总为假
将相应的条件转为常量字段
```sql
(key1 < 'abc' AND TRUE) OR (key1 < 'bar' AND TRUE) OR (FALSE)
```
将不必须的TRUE和FALSE字段删除
```sql
(key1 < 'abc') OR (key1 < 'bar')
```
4  将重叠的间隔组合成一个将产生用于范围扫描的最终条件
```sql
(key1 < 'bar')
```

一般而言(如上例中所展示的)，用于范围扫描的条件比WHERE子句的限制要小。MySQL执行额外的检查以过滤出满足range条件但不满足WHERE子句的行。

范围条件提取算法可以处理任意深度的嵌套AND / OR构造，并且其输出不依赖于条件在WHERE子句中出现的顺序。
               
MySQL不支持使用范围查询函数时将多个范围进行合并。为了突破这一限制，可以使用UNION来合并独立的SELECT语句，只是需要将不同的条件语句写在不同的SELECT中

### 多值索引的范围查询

多值索引的条件查询是单值索引条件查询的扩展。多值索引的范围查询限制索引行在一个或者多个索引元组区间中。索引元组区间是定义在索引元组上并在索引上使用排序。

举例说明，考虑一个多指索引定义为key1(key_part1， key_part2, key_part3)，下列的key元组按索引顺序排列
```sql
key_part1  key_part2  key_part3
  NULL       1          'abc'
  NULL       1          'xyz'
  NULL       2          'foo'
   1         1          'abc'
   1         1          'xyz'
   1         2          'abc'
   2         1          'aaa'
```
条件key_part = 1定义了这个区间：
```sql
(1,-inf,-inf) <= (key_part1,key_part2,key_part3) < (1,+inf,+inf)
```
这个区间覆盖了第四，第五和第六个索引元组，可以使用区间范围查找函数

与此相反，条件key_part3 = 'abc'就没有定义一个单独的区间而不能使用区间范围查找函数

下面的描述详细描述了多值索引的工作方式

- 对于HASH索引，包含相同值的区间都可以被使用。这意味着以下形式的条件可以产生区间
```sql
    key_part1 cmp const1
AND key_part2 cmp const2
AND ...
AND key_partN cmp constN;
```
这里，const1, const2,...都是常量，cmp代表 =, <=>, 或者 IS NULL操作符中的一个，条件覆盖了所有的索引(即N个条件完全匹配索引中的N个字段)。比如说，下面是三部分HASH索引的范围条件：
```sql
key_part1 = 1 AND key_part2 IS NULL AND key_part3 = 'foo'
```
关于如何定义常量，已经在[Range Access Method for Single-Part Indexes.](https://dev.mysql.com/doc/refman/8.0/en/range-optimization.html#range-access-single-part)进行了说明。

- 对于BTREE索引，一个区间可以用在使用AND连接的多个条件中，每个条件将key的部分字段使用=, <=>, IS NULL, >, <, >=, <=, !=, <>, BETWEEN, 或者LIKE模式(模式不以通配符开头)的操作符与常量想比较。只要每个单独的索引都能匹配到条件，区间就是可用的(或者使用<>,!=划分的两个区间)。

当使用的操作符为=，<=>或者IS NULL时，优化器会尝试添加其他的索引部分。如果使用的是 >, <, >=, <=, !=, <>, BETWEEN, 或者 LIKE操作符，优化器则不考虑使用其他索引部分。在下面的表达式中，优化器会首先使用=进行第一次比较，接下来使用>=进行第二部分的比较，但是下来就不会使用索引的第三部分进行区间构造。
```sql
key_part1 = 'foo' AND key_part2 >= 10 AND key_part3 > 10
```
归一的区间是
```sql
('foo',10,-inf) < (key_part1,key_part2,key_part3) < ('foo',+inf,+inf)
```
可能创建的间隔包含的行比初始条件多。例如，前面的间隔包含不满足初始条件的值('foo'， 11,0)。

- 如果条件覆盖的各个子区间是用OR进行连接的，那么最终的区间将是这些区间的并集。如果是使用AND进行连接，那么最终区间是这些区间的交际，比如说，在下面的两部分索引的条件
```sql
(key_part1 = 1 AND key_part2 < 2) OR (key_part1 > 5)
```
最终区间是
```sql
(1,-inf) < (key_part1,key_part2) < (1,2)
(5,-inf) < (key_part1,key_part2)
```
在这个例子中，第一行的区间使用了一个索引的左边界范围和两个索引的右边界。在[EXPLAIN](https://dev.mysql.com/doc/refman/8.0/en/explain.html)的输出中可以看出使用到索引的最大前缀长度。

在一些案例中，key_len提示用到了索引的哪个部分，但是可能并不是你所期待的。假设key_part1和key_part2可以为NULL，那么key_len在如下场景中展示的则是两部分索引的长度：
```sql
key_part1 >= 1 AND key_part2 < 2
```
实际上这个条件会被转换为
```sql
key_part1 >= 1 AND key_part2 IS NOT NULL
```
有关如何执行优化以组合或消除单值索引上的范围条件的间隔的描述，参考[Range Access Method for Single-Part Indexes](https://dev.mysql.com/doc/refman/8.0/en/range-optimization.html#range-access-single-part)。对多部分指标的距离条件也执行类似的步骤。

### 多值比较的等值范围优化

考虑如下表达式，col_name是一个索引列
```sql
col_name IN(val1, ..., valN)
col_name = val1 OR ... OR col_name = valN
```
如果col_name等于val1到valN之间的任何值，那表达式将为真。这些比较是等值范围比较(这个范围是一个单独的区间)。优化器会如下评估读匹配行和匹配范围
- 如果col_name上是一个unique索引，那么评估的范围是1因为最多只能有一行有用给定数据
- 如果在col_name上的是一个非unique索引，那么优化器在评估区间匹配的行数时需要深入索引和索引统计信息。

使用索引，优化器会使用范围末尾的值与范围区间内的行进行评估。比如说，表达式col_name IN(10,20,30)有三个等值范围，优化器会在每个范围进行两次下探进行行评估。成对的下探形成对行值的评估。

索引下探提供准确的行评估，但是随着比较次数的增加，优化器不在逐一进行行评估。使用索引的统计信息虽然准确度稍低，但是在大范围行评估的速度上会限制提升。

[eq_range_index_dive_limit](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_eq_range_index_dive_limit)系统变量允许你配置从索引行评估到索引统计信息分析的行数值。比如说，需要允许使用等值区间比较索引下探的最大行数是N，那么设置eq_range_index_dive_limit为N+1。如果需要禁用索引数据分析，直接设置eq_range_index_dive_limit为0.

更新表索引统计信息以获得最佳估计，使用[ANALYZE TABLE](https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html)

在MySQL8.0以前，除非设置了eq_range_index_dive_limit变量，没法跳过使用索引下探进行索引有效评估。在MySQL8.0，当满足如下所有条件时是可以做到的：
- 查询是单表查询，不需要连表
- 设置了单个索引的FORCE INDEX提示。其思想是，如果强制使用索引，那么执行对索引的下探的并没有其他额外开销。
- 索引不是非独立索引或者全文索引
- 没有子查询
- 没有使用DISTINCT, GROUP BY, 或者ORDER BY语句 

对于[EXPLAIN FOR CONNECTION](https://dev.mysql.com/doc/refman/8.0/en/explain.html),如果索引下探被跳过，那么输出的变化将如下所示：
- 对于传统的输出，rows和filtered值为NULL
- 对于JSON输出，rows_examined_per_scan和rows_produced_per_join不显示，skip_index_dive_due_to_force为true，消耗统计是不准确的

对于EXPLAIN输出而言，跳过索引下探并没有变化。

在执行查找哪个索引的下探被跳过了以后，在对应的[INFORMATION_SCHEMA.OPTIMIZER_TRACE](https://dev.mysql.com/doc/refman/8.0/en/information-schema-optimizer-trace-table.html)表中将包含一个 skipped_due_to_force_index值的index_dives_for_range_access字段。

### 跳跃扫描范围查询函数

考虑到如下场景
```sql
CREATE TABLE t1 (f1 INT NOT NULL, f2 INT NOT NULL, PRIMARY KEY(f1, f2));
INSERT INTO t1 VALUES
  (1,1), (1,2), (1,3), (1,4), (1,5),
  (2,1), (2,2), (2,3), (2,4), (2,5);
INSERT INTO t1 SELECT f1, f2 + 5 FROM t1;
INSERT INTO t1 SELECT f1, f2 + 10 FROM t1;
INSERT INTO t1 SELECT f1, f2 + 20 FROM t1;
INSERT INTO t1 SELECT f1, f2 + 40 FROM t1;
ANALYZE TABLE t1;

EXPLAIN SELECT f1, f2 FROM t1 WHERE f2 > 40;
```


为了执行这个查询，MySQL可以选择一个索引扫描来获取所有的行(索引包括所有要选择的列)，然后应用WHERE子句中的f2 > 40条件来生成最终的结果集。

范围扫描比全索引扫描更有效，但不能在本例中使用，因为对于第一个索引列f1没有任何条件。然而，在MySQL 8.0.13中，优化器可以执行多个范围扫描，使用一种名为Skip Scan的方法对每个f1值执行一次扫描，该方法与松散索引扫描(Loose Index Scan)类似。具体参考[ Section 8.2.1.17, “GROUP BY Optimization”](https://dev.mysql.com/doc/refman/8.0/en/group-by-optimization.html):

1. 索引第一列f1上跳跃不同值;
2. 再在剩下的索引列上，为每一个不同的前缀值进行f2 > 40的子范围扫描。

为了充分展示前面所说的数据，算法会如下操作：

1. 获取索引列第一列的第一个去重值(f1 = 1)
2. 生成关于第一列的第一个去重值和第二列的扫描范围(f1 = 1 AND f2 > 40)
3. 执行范围扫描
4. 获取第一列的第二个去充值(f1 = 2)
5. 生成关于第一列的第二个去重值和第二列的扫描范围(f1 = 1 AND f2 > 40)
6. 执行范围扫描

使用此策略可以减少被访问的行数，因为MySQL跳过不符合每个构造范围的行。此跳过扫描访问方法适用于以下条件：

- 表T必须要至少有一个复合索引，索引形式形如([A_1, ..., A_k,] B_1, ..., B_m, C [, D_1, ..., D_n])。索引的A和D部分可以为空，但是B和C不可以。
- 查询只能涉及到一个表
- 查询不能使用GROUP BY或者DISTINCT
- 查询仅限于索引列
- 在A_1，... A_k上的比较方式必须是等值比较，被比较的值必须是常量，包括IN操作符
- 查询必须是一个连接查询，即使用AND和OR条件。(cond1(key_part1) OR cond2(key_part1)) AND (cond1(key_part2) OR ...) AND ...
- C列必须有范围条件
- D列上的条件是允许的，但是D列上的索引条件必须和C列组合

使用跳过扫描在EXPLAIN的输出显示如下:

- 使用索引跳过时在Extra列显示使用了嗽散索引跳跃扫描方法
- 如果索引可以用于跳跃扫描，索引应当出现在possible_keys列中

使用跳跃扫描，优化器可以通过"skip scan"元素以下面所列的形式进行追踪，则可以看到一个"best_skip_scan_summary"元素。
```sql
"skip_scan_range": {
  "type": "skip_scan",
  "index": index_used_for_skip_scan,
  "key_parts_used_for_access": [key_parts_used_for_access],
  "range": [range]
}
```

如果跳跃扫描被选作最好的范围扫描方式，则写入"chosen_range_access_summary"。如果跳跃扫描被选作最佳访问方式，

跳过扫描的使用取决于[optimizer_switch](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_optimizer_switch)优系统变量的w[skip_scan](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html#optflag_skip-scan)标志的值。参考[Section 8.9.2, “Switchable Optimizations”](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html)。默认标志为打开，可以通过设置skip_off来关闭。

除了通过optimizer_switch系统变量来在会话及级别控制跳跃扫描的控制优化器。支持在每条语句的基础上影响优化器的优化器提示，具体参考[ Section 8.9.3, “Optimizer Hints”](https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html)。

### 行构造表达式的范围优化

优化器可以对一下形式的查询使用范围扫描访问方法
```sql
SELECT ... FROM t1 WHERE ( col_1, col_2 ) IN (( 'a', 'b' ), ( 'c', 'd' ));
```
而在此之前，需要将查询写成这种形式
```sql
SELECT ... FROM t1 WHERE ( col_1 = 'a' AND col_2 = 'b' )
OR ( col_1 = 'c' AND col_2 = 'd' );
```
优化器执行范围扫描的查询必须满足如下条件:

- 只能使用IN，而不能使用NOT IN
- 在IN表达式的左边，只能包含列
- 在IN表达式的右边，只能包含运行时的常量，或者是字面常量或者是在执行期间绑定到常量的本地列引用
- 在IN表达式的右边，多余一个行构造器

更多详细信息请参考[Section 8.2.1.22, “Row Constructor Expression Optimization”](https://dev.mysql.com/doc/refman/8.0/en/row-constructor-optimization.html)

### 范围优化中的限制内存使用

为控制范围优化器可用的内存，使用[ range_optimizer_max_mem_size](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_range_optimizer_max_mem_size)系统变量:

- 值为0表示没有限制
- 如果值大于0，优化器将跟踪在考虑范围访问方法时所消耗的内存。如果即将超过指定的限制，则放弃范围访问方法，而考虑其他方法，包括全表扫描。如果发生这种情况，会出现以下警告(其中N是当前range_optimizer_max_mem_size值)
```sql
Warning    3170    Memory capacity of N bytes for
                   'range_optimizer_max_mem_size' exceeded. Range
                   optimization was not done for this query.
```  
- 对于UPDATE和DELETE语句，如果优化器失败回退到全表扫描，并且[sql_safe_updates](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_sql_safe_updates)系统变量已设置，则会产生一个错误而非一个警告。因为实际上，没有任何一个索引被用来判定那一行将被修改。详情参考[Using Safe-Updates Mode (--safe-updates).](https://dev.mysql.com/doc/refman/8.0/en/mysql-tips.html#safe-updates)

对于超出可用范围的单个查询，优化器会退回到不太优化的计划，这种情况下增加[range_optimizer_max_mem_size](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_range_optimizer_max_mem_size)可能有助于提升效率。

评估一个范围查找语句需要使用多少内存，使用如下指南
- 对于如下所示的简单查询，对于范围访问方法有一个候选索引，每个谓词与OR组合使用大约230字节
```sql
SELECT COUNT(*) FROM t
WHERE a=1 OR a=2 OR a=3 OR .. . a=N;
```

- 相似的，使用如下查询，每个使用AND进行连接则使用大约125字节

```sql
SELECT COUNT(*) FROM t
WHERE a=1 AND b=1 AND c=1 ... N;
```
- 对于使用IN查询
```sql
SELECT COUNT(*) FROM t
WHERE a IN (1,2, ..., M) AND b IN (1,2, ..., N);
```

在IN列表中的每个值都是用OR进行连接的。如果有两个列表，那么最终的数值数目就是两个列表数目的乘积。因此，这个使用OR进行连接的总数是M * N。

## 8.2.1.3 索引归并优化

索引归并访问方法检索具有多个范围扫描的行，并将它们的结果归并为一个。这种访问方法只合并来自单个表的索引扫描，而不是跨多个表的扫描。归并优化可以产生扫描部分的并集，交际，交集的并集。

索引合并到例子如下所示
```sql
SELECT * FROM tbl_name WHERE key1 = 10 OR key2 = 20;

SELECT * FROM tbl_name
  WHERE (key1 = 10 OR key2 = 20) AND non_key = 30;

SELECT * FROM t1, t2
  WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE 'value%')
  AND t2.key1 = t1.some_col;

SELECT * FROM t1, t2
  WHERE t1.key1 = 1
  AND (t2.key1 = t1.some_col OR t2.key2 = t1.some_col2);
```

::: tip 
索引优化算法有如下已知的限制
- 如果查询有一个复杂的WHERE字句，有多个AND/OR的嵌套，MySQL不会选择最优策略，尝试使用以下恒等转换
```sql
(x AND y) OR z => (x OR z) AND (y OR z)
(x OR y) AND z => (x AND z) OR (y AND z)
```
- 索引归并不能应用再全文索引上
:::

在EXPLAIN的输出钟，索引归并方法会在type列钟以index_merge的结果出现。在这种情况下，key这一列显示了使用到的索引，key_len包含了这些索引中的使用到的最长索引长度。

索引合并访问方法有多个算法，在EXPLAIN输出中的Extra列中显示
- Using intersect(...)
- Using union(...)
- Using sort_union(...)

下面的的部分将更详细得描述这些算法。优化器在索引合并优化方法和其他可选项中进行评估选择。

#### 索引归并交集访问算法

这种访问算法在WWHERE语句可以被转换成多个不同索引的合并，并且每个条件是以下几种情形之一的:

- 有N个如下形式的表达式，并且索引包含了所有字段，即索引被全覆盖了
```sql
key_part1 = const1 AND key_part2 = const2 ... AND key_partN = constN
```
- InnoDB表中主键上的任何范围条件
```sql
SELECT * FROM innodb_table
  WHERE primary_key < 10 AND key_col1 = 20;

SELECT * FROM tbl_name
  WHERE key1_part1 = 1 AND key1_part2 = 2 AND key2 = 2;
```
索引归并的交际算法对所有使用的索引执行同步扫描，并生成从合并索引扫描中接收到的行序列的交集。

如果所有的列都被索引覆盖，不会扫描全表(EXPLAIN输出中的Extra字段包含USING index)，下面是这种示例
```sql
SELECT COUNT(*) FROM t1 WHERE key1 = 1 AND key2 = 1;
```
如果所使用的索引未覆盖查询中的所有列，只有当满足所有已使用键的范围条件时，才扫描所有行。

如果其中一个归并条件是InnoDB表主键上的条件，那么它不用于行检索，而是用于过滤使用其他条件检索的行。

#### 索引归并的合并算法

这种条件的算法于上面的索引归并交集算法类似。不同的是使用OR进行各个条件连接，并且每个条件满足下述之一的:

- 有N个如下形式的表达式，并且索引包含了所有字段，即索引被全覆盖了
```sql
key_part1 = const1 OR key_part2 = const2 ... OR key_partN = constN
```
::: warning 译者注
源文中这里是使用AND连接的，实际上应该是OR
:::

- InnoDB表中主键上的任何范围条件
- 索引归并交集算法适用的
```sql
SELECT * FROM tbl_name
  WHERE key_col1 < 10 OR key_col2 < 20;

SELECT * FROM tbl_name
  WHERE (key_col1 > 10 OR key_col2 = 20) AND nonkey_col = 30;
```

#### 索引归并 排序-合并 访问算法

这种算法适用于所有范围条件使用OR进行连接，但是并不适用于索引归并的合并算法的

```sql
SELECT * FROM tbl_name
  WHERE key_col1 < 10 OR key_col2 < 20;

SELECT * FROM tbl_name
  WHERE (key_col1 > 10 OR key_col2 = 20) AND nonkey_col = 30;
```

索引归并排序-合并算法与索引归并合并算法的不同指出在于排序-合并必须先获取所有行的行ID，并且在返回任何行之前先排序。

#### 应用索引合并优化

索引归并是通过optimizer_switch系统变量中的index_merge, index_merge_intersection, index_merge_union, 和 index_merge_sort_union标识位所控制的。参考[Section 8.9.2, “Switchable Optimizations”](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html)。默认情况下，这些标识位都是开启的。为了之开启某一个算法，将index_merge设置为off，并将要开启的算法标志位设置为on。

除了使用optimizer_switch系统变量进行索引归并算法会话级别的开启控制，MySQL也支持在pre-statment中使用关键字提示MySQL进行优化。参考[Section 8.9.3, “Optimizer Hints”. ](https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html)。

## 8.2.1.4 哈希连接优化

从MySQL8.0.18开始，MySQL连接条件上没有索引的相等连接，使用哈希连接。比如说:
```sql
SELECT *
    FROM t1
    JOIN t2
        ON t1.c1=t2.c1;
```
哈希连接也可以在单表判定中存在一个或者多个索引时使用。

散列连接通常比以前版本的MySQL中使用的块嵌套循环算法(请参阅[Block Nested-Loop Join Algorithm](https://dev.mysql.com/doc/refman/8.0/en/nested-loop-joins.html#block-nested-loop-join-algorithm))更快，而且目的也就是为了这种场景而使用。MySQL8.0.20自开始移除了对块钱套循环的支持，之前使用块嵌套循环的都使用哈希连接来实现。

在本节下面的例子中，我们假设t1,t2,t3表是使用如下建表语句构建的
```sql
CREATE TABLE t1 (c1 INT, c2 INT);
CREATE TABLE t2 (c1 INT, c2 INT);
CREATE TABLE t3 (c1 INT, c2 INT);
```
在使用了哈希连接的地方，EXLPAIN输出如下
```sql
mysql> EXPLAIN
    -> SELECT * FROM t1
    ->     JOIN t2 ON t1.c1=t2.c1\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: t2
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: Using where; Using join buffer (hash join)
```
(在MySQL8.0.20以前，必须要包含FORMAT=TREE选项，以查看给定连接是否使用散列连接)

[EXPLAIN ANALYZE](https://dev.mysql.com/doc/refman/8.0/en/explain.html#explain-analyze)也展示哈希连接的使用情况。

哈希连接也用于多表关联查询，只要在每对连接的表的连接条件中包含一个等值连接，比如说下面这个:
```sql
SELECT * FROM t1
    JOIN t2 ON (t1.c1 = t2.c1 AND t1.c2 < t2.c2)
    JOIN t3 ON (t2.c1 = t3.c1);
```
如上例所示使用了内连接，非等值关联条件会在等值关联完成以后应用为过滤器。(对于外连接，包括左连接，半连接，反连接，他们都被打印为连接的一部分。这些连接会在下面的示例中说明)这个在EXLAIN输出中可以看出。
```sql
mysql> EXPLAIN FORMAT=TREE
    -> SELECT *
    ->     FROM t1
    ->     JOIN t2
    ->         ON (t1.c1 = t2.c1 AND t1.c2 < t2.c2)
    ->     JOIN t3
    ->         ON (t2.c1 = t3.c1)\G
*************************** 1. row ***************************
EXPLAIN: -> Inner hash join (t3.c1 = t1.c1)  (cost=1.05 rows=1)
    -> Table scan on t3  (cost=0.35 rows=1)
    -> Hash
        -> Filter: (t1.c2 < t2.c2)  (cost=0.70 rows=1)
            -> Inner hash join (t2.c1 = t1.c1)  (cost=0.70 rows=1)
                -> Table scan on t2  (cost=0.35 rows=1)
                -> Hash
                    -> Table scan on t1  (cost=0.35 rows=1)
```

如上面的输出所示，多个哈希连接可以用于(也实际用于)夺标等值连接条件中。

在MySQL8.0.20前，哈希连接在每个连接表配对没有至少一个等值关联条件时无法使用，这时会使用较慢的块嵌套循环算法。在MySQL8.0.20以后，哈希连接也适用于之前不适用的场景，如下面所示：
```sql
mysql> EXPLAIN FORMAT=TREE
    -> SELECT * FROM t1
    ->     JOIN t2 ON (t1.c1 = t2.c1)
    ->     JOIN t3 ON (t2.c1 < t3.c1)\G
*************************** 1. row ***************************
EXPLAIN: -> Filter: (t1.c1 < t3.c1)  (cost=1.05 rows=1)
    -> Inner hash join (no condition)  (cost=1.05 rows=1)
        -> Table scan on t3  (cost=0.35 rows=1)
        -> Hash
            -> Inner hash join (t2.c1 = t1.c1)  (cost=0.70 rows=1)
                -> Table scan on t2  (cost=0.35 rows=1)
                -> Hash
                    -> Table scan on t1  (cost=0.35 rows=1)
```
(本节稍后将提供其他示例。)

哈希连接可以用于笛卡尔成绩，即没有特殊的连接条件，如下面的例子所示:
```sql
mysql> EXPLAIN FORMAT=TREE
    -> SELECT *
    ->     FROM t1
    ->     JOIN t2
    ->     WHERE t1.c2 > 50\G
*************************** 1. row ***************************
EXPLAIN: -> Inner hash join  (cost=0.70 rows=1)
    -> Table scan on t2  (cost=0.35 rows=1)
    -> Hash
        -> Filter: (t1.c2 > 50)  (cost=0.35 rows=1)
            -> Table scan on t1  (cost=0.35 rows=1)
```

在MySQL 8.0.20及以后版本中，不再需要包含至少一个等连接条件才能使用使用散列连接。这意味着下面的示例列表中都可以优化使用哈希连接:

-  内部非等值连接(Inner non-equi-join): 
```sql
mysql> EXPLAIN FORMAT=TREE SELECT * FROM t1 JOIN t2 ON t1.c1 < t2.c1\G
*************************** 1. row ***************************
EXPLAIN: -> Filter: (t1.c1 < t2.c1)  (cost=4.70 rows=12)
    -> Inner hash join (no condition)  (cost=4.70 rows=12)
        -> Table scan on t2  (cost=0.08 rows=6)
        -> Hash
            -> Table scan on t1  (cost=0.85 rows=6)
```
- Semijoin(半连接): 
```sql
mysql> EXPLAIN FORMAT=TREE SELECT * FROM t1 
    ->     WHERE t1.c1 IN (SELECT t2.c2 FROM t2)\G
*************************** 1. row ***************************
EXPLAIN: -> Nested loop inner join
    -> Filter: (t1.c1 is not null)  (cost=0.85 rows=6)
        -> Table scan on t1  (cost=0.85 rows=6)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (c2=t1.c1)
        -> Materialize with deduplication
            -> Filter: (t2.c2 is not null)  (cost=0.85 rows=6)
                -> Table scan on t2  (cost=0.85 rows=6)
```
- Antijoin(反连接)
```sql
mysql> EXPLAIN FORMAT=TREE SELECT * FROM t2 
    ->     WHERE NOT EXISTS (SELECT * FROM t1 WHERE t1.col1 = t2.col1)\G
*************************** 1. row ***************************
EXPLAIN: -> Nested loop antijoin
    -> Table scan on t2  (cost=0.85 rows=6)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (c1=t2.c1)
        -> Materialize with deduplication
            -> Filter: (t1.c1 is not null)  (cost=0.85 rows=6)
                -> Table scan on t1  (cost=0.85 rows=6)
```
- 左外连接(Left outer join):
```sql
mysql> EXPLAIN FORMAT=TREE SELECT * FROM t1 LEFT JOIN t2 ON t1.c1 = t2.c1\G
*************************** 1. row ***************************
EXPLAIN: -> Left hash join (t2.c1 = t1.c1)  (cost=3.99 rows=36)
    -> Table scan on t1  (cost=0.85 rows=6)
    -> Hash
        -> Table scan on t2  (cost=0.14 rows=6)
```
- 右外连接 (Right outer join 注意MySQL将所有右外连接都重写为左外连接)
```sql
mysql> EXPLAIN FORMAT=TREE SELECT * FROM t1 RIGHT JOIN t2 ON t1.c1 = t2.c1\G
*************************** 1. row ***************************
EXPLAIN: -> Left hash join (t1.c1 = t2.c1)  (cost=3.99 rows=36)
    -> Table scan on t2  (cost=0.85 rows=6)
    -> Hash
        -> Table scan on t1  (cost=0.14 rows=6)
```

在默认条件下，MySQL8.018以后在任何可能的情况下都使用哈希连接。可以通过控制使用［BNL］(https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-table-level)和NO_BNL优化器提示来使用或者禁用。

(MySQL 8.0.18支持 hash_join=on或 hash_join=off作为 optimizer_switch系统变量的设置的一部分，以及优化器提示HASH_JOIN或者NO_HASH_JOIN。在MySQL 8.0.19及以后版本中，这些不再有任何效果。)

哈希连接的内存使用可以使用[join_buffer_size](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_join_buffer_size)系统变量来控制;哈希连接不能使用超过此数量的内存。当哈希连接所需的内存超过可用内存时，MySQL通过使用磁盘上的文件来处理。如果发生这种情况，您应该知道，如果散列连接无法装入内存，并且创建的文件超过了设置的[open_files_limit](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_open_files_limit)，则连接可能不会成功。为了避免这种情况发生，可以尝试下面的改变方式:

- 增加join_buffer_size的大小，以便散列连接不会溢出到磁盘。
- 增加open_files_limit的大小

在MySQL8.0.10以后，哈希连接的连接缓冲区是递增分配的。因此，您可以将join_buffer_size设置得更高，而无需使用分配大量RAM的小查询，但是外部连接将分配整个缓冲区。在MySQL 8.0.20及以后版本中，散列连接也用于外连接(包括反连接和半连接)，因此这不再是一个问题。

## 8.2.1.5 引擎条件下推优化

这种优化提高了在非索引列和常量之间直接比较的效率。在这种情况下，条件被下推到存储引擎进行计算。这种优化只能由NDB存储引擎使用。

对于NDB集群，这种优化可以省去法出查询的服务器在集群节点网络间传输不匹配的行，相比于没有使用条件下推，使用的了会块５－１０被。

假设一个NDB集群的表定义如下：
```sql
CREATE TABLE t1 (
    a INT,
    b INT,
    KEY(a)
) ENGINE=NDB;
```
引擎条件下推可以在下面的一种情况下使用，即查询包含非索引列与常量的比较
```sql
SELECT a, b FROM t1 WHERE b = 10;
```
这种情况下在EXPLAIN的输出如下：
```sql
mysql> EXPLAIN SELECT a,b FROM t1 WHERE b = 10\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 10
        Extra: Using where with pushed condition
```
不过，引擎条件下推不能被如下的查询使用
```sql
SELECT a,b FROM t1 WHERE a = 10;
```
引擎条件下推在a列上有索引的情况下是不适用的。(在这种条件下，索引访问方法效率更高，所以会被优先选择)

当索引列使用<或者>进行比较的话，也可以使用岁哦因条件下推
```sql
mysql> EXPLAIN SELECT a, b FROM t1 WHERE a < 2\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
         type: range
possible_keys: a
          key: a
      key_len: 5
          ref: NULL
         rows: 2
        Extra: Using where with pushed condition
```

其他可以使用的索引条件下推包括下述情况

-  column [NOT] LIKE pattern 
   pattern必须是一个包含匹配模式的字面常量，相关语法参见[Section 12.8.1, “String Comparison Functions and Operators”. ](https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html)
   
- column IS [NOT] NULL
- column IN (value_list)
  value_list里的每个值必须都是字面常量
- column BETWEEN constant1 AND constant2 
  constant1和constant2值必须都是字面常量
  
在上述的所有情况下，可以将条件转换为列和常量之间一次或多次直接比较的形式。

引擎条件下推是默认启用的。为了在服务器启动时就取消开启，将optimizer_switch系统变量中的engine_condition_pushdown标识位设置为off。比如说，在my.conf文件中，可以使用下面的语句。
```sql
[mysqld]
optimizer_switch=engine_condition_pushdown=off
```
在运行时，像这样禁用引擎条件下推
```sql
SET optimizer_switch='engine_condition_pushdown=off';
```
**限制** 引擎条件下推收到下述条件限制：
- 引擎条件下推只支持NDB索引
- 在NDB 8.0.18之前，只可以将列与计算为常量的常量或表达式进行比较。在NDB 8.0.18及以后版本中，只要列具有完全相同的类型，包括相同的符号、长度、字符集、精度和规模，就可以相互比较。
- 比较的列不能是BLOB，TEXT，JSON，BIT或者ENUM
- 字符串类型的比较必须有相同的排序方式
- 连接并不被直接支持。包含多个表的条件在可能的条件下被分开下推。使用扩展的EXPLAIN来查看究竟哪些条件被实际下推了。参考[Section 8.8.3, “Extended EXPLAIN Output Format”. ](https://dev.mysql.com/doc/refman/8.0/en/explain-extended.html)。

以前，引擎条件下推仅限于引用将条件下推到的同一表中的列值。在NDB8.0.16以后，查询计划中前面表中的列值也可以从推入条件中引用。这减少了连接处理期间SQL节点必须处理的行数。过滤也可以在LDM线程中并行执行，而不是在单个mysqld进程中执行。这有可能显著提高查询的性能。

从NDB8.0.20开始，如果在同一个连接嵌套中使用的任何表，或者在连接nmests之上所依赖的任何表上没有不可推的条件，使用扫描的外连接可以被下推。对于半连接也同样使用，只要优化策略是firstMatch。参考[Section 8.2.2.1, “Optimizing IN and EXISTS Subquery Predicates with Semijoin Transformations”](https://dev.mysql.com/doc/refman/8.0/en/semijoins.html)。
              
在以下两种情况下，连接算法不能与前一个表中的引用列结合使用：
1. 当引用的之前的任何一个表在缓存索引中。这种情况下，扫描滤除的表中取出的每一行都匹配缓存中的行。这意味着在生成扫描过滤器时，不存在可以从哪个特定行获取列值的情况。
2. 当使用的列来自一个的子操作的连接下推。这是因为扫描过滤器产生时还没从之前的连接索引中取回要引用的行，现在却要引用这些行。

## 8.2.1.6 索引条件下推优化

索引条件下推(Index Condition Pushdown ,ICP)是MySQL使用索引返回行数据时进行的一种优化方式。没有ICP，存储需要引擎遍历索引以定位基表中的行，并将它们返回给MySQL服务器，该服务器计算行的WHERE条件。在启用ICP的情况下，如果WHERE条件的一部分可以通过只使用索引中的列来计算，那么MySQL服务器将这一部分WHERE条件下推到存储引擎。然后，存储引擎使用索引条目来计算已推入的索引条件，只有满足这个条件，才从表中读取行。ICP可以减少存储引擎访问基表和M存储引擎的次数。

索引条件下推优化的适用性取决于这些条件：

- ICP用于在需要全表扫描时使用range, ref, eq_ref, 和ref_or_null访问方法
- ICP可用于InnoDB和M有ISAM表，包括分区表
- 对于InnoDB表，ICP只用于二级索引。ICP的目标是降低扫描表的行数以便减少IO操作。对于InnoDB集群索引，所有记录都被存储到InnoDB的缓存，使用ICP无法减少磁盘I/O
- 在虚拟生成的列上创建的二级索引不支持ICP。 InnoDB支持虚拟生成列上的二级索引
- 不能下推引用子查询的条件
- 引用存储函数的条件不能下推。存储引擎不能调用存储函数。
- 触发条件不能下推(更多触发条件参考[Section 8.2.2.3, “Optimizing Subqueries with the EXISTS Strategy”](https://dev.mysql.com/doc/refman/8.0/en/subquery-optimization-with-exists.html))

为了理解这种优化的工作原理，首先考虑在索引条件下推没使用时如何进行索引扫描：
1. 获取下一行。首先读取索引元组，使用索引元组定位并读取整行数据
2. 测试在这个表上的WHERE条件，根据测试结果保留或者丢弃这一行

使用索引条件下推，过程则是这样的：
1. 获取下一行的索引元组(不需要全表扫描)
2. 使用这个表的WHERE条件去检测索引列。如果条件不匹配，则索引元组前进到下一行
3. 如果条件满足了，则使用索引元组定位并扫描整行数据
3. 测试WHERE剩余条件是否满足，并基于结果保留或丢弃这一行

当使用了索引条件下推时，EXPLAIN会在Extra列显示Using index condition。它没有显示Using index，因为当必须读取整个表行时，这并不适用。

假设一个表是关于人员及其住址的信息，表的索引定义为INDEX(zipcode, lastname, firstname)。加入我们知道一个人的zipcode但不确定这个人的lastname, 可以这样查询
```sql
SELECT * FROM people
  WHERE zipcode='95054'
  AND lastname LIKE '%etrunia%'
  AND address LIKE '%Main Street%';
```

MySQL可以使用索引zipcode='95054'来扫描人员。第二部分(lastname LIKE '%etrunia%')没法用来限制需要扫描的行。所以没有索引条件下推，查询必须获取所有包含zipcode='95054'的所有行。

有了索引条件下推，MySQL在获取全行数据之前先检查'lastname LIKE '%etrunia%'。这样就避免了获取匹配索引元组中符合zipcode的条件但却不符合lastname条件的行数据。

索引条件下推默认是开启的。可以通过控制optimizer_switch系统变量中的index_condition_pushdown来实现开关：
```sql
SET optimizer_switch = 'index_condition_pushdown=off';
SET optimizer_switch = 'index_condition_pushdown=on';
```
参考[Section 8.9.2, “Switchable Optimizations”. ](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html)

## 8.2.1.7 嵌套循环连接算法

MySQL在表之间(以及表的变种)使用嵌套循环算法

- 嵌套循环算法(Nested-Loop Join Algorithm)
- 块套循环算法(Block Nested-Loop Join Algorithm)

#### 嵌套循环算法

一个简单的嵌套循环算法 (NLJ)从链接的第一个表中读取数据行，并循环将每一行传给连接的下一个表。只要还有多少表要联接，这个过程就会重复多少次。

假设三个表t1,t2,t3相连接，并且使用下列连接方式：
```sql
Table   Join Type
t1      range
t2      ref
t3      ALL
```

如果使用嵌套循环算法，连接会这样执行
```sql
for each row in t1 matching range {
  for each row in t2 matching reference key {
    for each row in t3 {
      if row satisfies join conditions, send to client
    }
  }
}
```
由于嵌套循环算法需要从外层循环向内层循环传递行数据，所以会多次读取内层的行。

#### 块嵌套循环

块嵌套循环(BNL)使用缓存记录外层循环的数据以减少传递到内层循环需要读取行的次数。比如说，如果有10行数据被读取到缓存中，那么内层循环比较这10行数据时只需要从缓存中取数据而不是重新读表。这就减少了内层循环需要读取行数的数量级。

在MySQL8.0.18以前，这种算法只应用在没有索引可用的相等连接；在MySQL8.0.18以后，可以使用哈希连接进行优化。从MySQL8.0.20开始，MySQL不再使用块嵌套循环，而统一使用哈希连接进行优化。参考[Section 8.2.1.4, “Hash Join Optimization”. ](https://dev.mysql.com/doc/refman/8.0/en/hash-joins.html)

MySQL连接缓存有如下特征：

- 连接缓存可以在连接类型为ALL,index(换句话说，当没有可用索引，需要扫描全表的行或者是全部索引)或者是range。使用缓存也可以适用于外连接，参考[Section 8.2.1.12, “Block Nested-Loop and Batched Key Access Joins”. ](https://dev.mysql.com/doc/refman/8.0/en/bnl-bka-optimization.html)

- 连接缓存不会为首个非常量表分配，即使连接类型是ALL或者index

- 只缓存相关列，而不是整行数据

- 系统变量join_buffer_size决定了一个查询中缓存的大小

- 被多个连接使用的缓存也可以被缓存下来，所以给定的查询可能使用多个连接缓存

- 缓存在执行连接前被分配，在查询完成后被释放

前面提到的使用NLJ算法(没使用缓存)的例子，在使用缓存的情况下会如下执行：
```sql
for each row in t1 matching range {
  for each row in t2 matching reference key {
    store used columns from t1, t2 in join buffer
    if buffer is full {
      for each row in t3 {
        for each t1, t2 combination in join buffer {
          if row satisfies join conditions, send to client
        }
      }
      empty join buffer
    }
  }
}

if buffer is not empty {
  for each row in t3 {
    for each t1, t2 combination in join buffer {
      if row satisfies join conditions, send to client
    }
  }
}
```

如果s是保存t1, t2的连接缓存的大小，c是缓存中二者连接的次数，则t3表的扫描次数是：
```sql
(S * C)/join_buffer_size + 1
```

当join_buffer_size大小增大，则t3的扫描次数降低，当join_buffer_size增大到能够存下前面所有行的连接，增加join_buffer_size将不再提升速度。

## 8.2.1.8 嵌套连接优化

表示连接的语法允许嵌套连接。下面的讨论参考[Section 13.2.10.2, “JOIN Clause”. ](https://dev.mysql.com/doc/refman/8.0/en/join.html)所描述的连接语法。

table_factor的语法是SQL标准的扩展。SQL标准只接受表引用(table_reference)，而不是用括号包含的表引用的列表。如果我们将逗号连接的表索引视作等价于内连接，那么这是一个保守的扩展。比如说：
```sql
SELECT * FROM t1 LEFT JOIN (t2, t3, t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)
```
等价于
```sql
SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)
```

在MySQL中，交叉连接(CROSS JOIN)在语法上等同于内连接(INNER JOIN)，他们可以相互替代。在标准的SQL中，他们并不相同。内连接与ON子句一起使用，交叉连接则不然。

简而言之，在只包含内连接的表达式中，括号可以被忽略。考虑下面的语句：
```sql
t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)
   ON t1.a=t2.a
```
在移除了括号并将左边的操作分组，表达式将转变成如下形式：
```sql
(t1 LEFT JOIN t2 ON t1.a=t2.a) LEFT JOIN t3
    ON t2.b=t3.b OR t2.b IS NULL
```
不过，这两个表达式并不完全相同。假设表t1,t2,t3有如下状态：

- 表t1包含行(1),(2)
- 表t2包含行(1),(101)
- 表t3包含行(101)

在这个情况下，第一个表达式返回的结果集包含行(1,1,101,101), (2,NULL,NULL,NULL)，而第二个表达式返回(1,1,101,101), (2,NULL,NULL,101): 
```sql
mysql> SELECT *
       FROM t1
            LEFT JOIN
            (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)
            ON t1.a=t2.a;
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL | NULL |
+------+------+------+------+

mysql> SELECT *
       FROM (t1 LEFT JOIN t2 ON t1.a=t2.a)
            LEFT JOIN t3
            ON t2.b=t3.b OR t2.b IS NULL;
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL |  101 |
+------+------+------+------+
```

在下面的例子中，外连接与内连接一起使用
```sql
t1 LEFT JOIN (t2, t3) ON t1.a=t2.a
```
这个表达式不能被转换成下面的表达式
```sql
t1 LEFT JOIN t2 ON t1.a=t2.a, t3
```
在现有表的状态下，两个表达式返回不同的结果行：
```sql
mysql> SELECT *
       FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a;
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL | NULL |
+------+------+------+------+

mysql> SELECT *
       FROM t1 LEFT JOIN t2 ON t1.a=t2.a, t3;
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL |  101 |
+------+------+------+------+
```

因此，在外连接中不可以忽略括号，因为那样可能该表原始表达式的结果。

更确切地说，不可以左外连接的右侧括号以及右外连接的左侧括号。换句话说，不可以忽略外连接操作中内连接表的括号。其他操作中的括号(外连接的表的操作)可以被忽略。

下面的表达式：
```sql
(t1,t2) LEFT JOIN t3 ON P(t2.b,t3.b)
```
等同于在表t1,t2,t3的任何在t2.b和t3.b的条件P
```sql
t1, t2 LEFT JOIN t3 ON P(t2.b,t3.b)
```
当连接表达式(连接表)中的连接操作的执行顺序不是从左到右时，我们讨论使用嵌套连接。考虑如下查询
```sql
SELECT * FROM t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b) ON t1.a=t2.a
  WHERE t1.a > 1

SELECT * FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a
  WHERE (t2.b=t3.b OR t2.b IS NULL) AND t1.a > 1
```

这些联查询包含嵌套连接
```sql
t2 LEFT JOIN t3 ON t2.b=t3.b
t2, t3
```

在第一个查询中，使用左连接操作形成嵌套连接。在第二个查询中，它是用内连接操作形成的。

第一个查询中，括号可以呗忽略，连接表达式的语法结构规定了连接操作的执行顺序。第二个查询中，括号没法忽略，尽管这里的连接表达式可以被无歧义地翻译。在扩展语法中，第二个查询中(t2,t3)的括号是必须的，尽管逻辑上查询可以在没有他们的情况下正确解析: 没有了括号语法结构上仍然是清晰的，LEFT JOIN和ON扮演了表达式(t2,t3)的左右括号功能，。

前面的例子说明了下面这些点：

- 对于只包含内连接的连接表达式，括号可以被去除，连接是从左向右，实际上，表连接可以以仍和顺序进行
- 对于包含外连接的或者内外连接相互混合的则不可以去除括号，因为这么做可能改变结果

使用嵌套外连接的执行顺序与嵌套内连接相同。更准确地说，是嵌套循环算法的一个变种。回想一下嵌套循环联接执行查询时使用的算法([Section 8.2.1.7, “Nested-Loop Join Algorithms”](https://dev.mysql.com/doc/refman/8.0/en/nested-loop-joins.html))。结社对T1,T2,T3表进行如下查询:
```sql
SELECT * FROM T1 INNER JOIN T2 ON P1(T1,T2)
                 INNER JOIN T3 ON P2(T2,T3)
  WHERE P(T1,T2,T3)
```

这里，P1(T1,T2)和P2(T3,T3)是在相同的关联条件(表达式上)，而P(T1,T2,T3)是在三个表上的关联条件

嵌套循环算法会以如下方式处理这个查询：
```sql
FOR each row t1 in T1 {
  FOR each row t2 in T2 such that P1(t1,t2) {
    FOR each row t3 in T3 such that P2(t2,t3) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
```

t1||t2||t3表示行t1,t2,t3中的列是如何连接成行的。在下面的例子中，表名的地方为NULL表示该表的每一列都使用NULL。比如说t1||t2||NULL表示取t1表和t2表的行数据以及t3的NULL数据来拼成数据。这样的行被称为NULL-填充。

现在考虑一个使用外连接嵌套索引：
```sql
SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON P2(T2,T3))
              ON P1(T1,T2)
  WHERE P(T1,T2,T3)
```
对于此查询，修改嵌套循环模式以获取:
```sql
FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t2 in T2 such that P1(t1,t2) {
    BOOL f2:=FALSE;
    FOR each row t3 in T3 such that P2(t2,t3) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f2=TRUE;
      f1=TRUE;
    }
    IF (!f2) {
      IF P(t1,t2,NULL) {
        t:=t1||t2||NULL; OUTPUT t;
      }
      f1=TRUE;
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
```
通常，对于外部连接操作中的第一个内部表的任何嵌套循环，都会引入一个标记，该标记在循环之前关闭，在循环之后检查。当外部表的当前行与表示内部操作数的表匹配时，将打开该标志。如果在循环结束时标志仍然关闭，则没有找到外部表的当前匹配行。这样的话，就使用NULL来填充内部循环表的数据。只有行数据满足所有外部循环的连接条件，结果行被传传递到外层循环。

在本例中，嵌入了由下面的表达式表示的外部连接表：
```sql
在本例中，嵌入了由下面的表达式表示的外部连接表
```
对于具有内部连接的查询，优化器可以选择不同的嵌套循环顺序，比如下面这个
```sql
FOR each row t3 in T3 {
  FOR each row t2 in T2 such that P2(t2,t3) {
    FOR each row t1 in T1 such that P1(t1,t2) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
```

对于包含外连接的查询，游乎其其只能选择外连接闲鱼内部表连接执行。因此，对于外连接查询，只可能又一个嵌套顺序。对于下面的查询，优化器评估两个不同的嵌套。在两个查询中，在两个嵌套中，T1必须在外部循环中处理，因为它在外部联接中使用。 T2和T3用于内部联接中，因此必须在内部循环中处理联接。因为是内连接，所以T2,T3的前后顺序都可以。
```sql
SELECT * T1 LEFT JOIN (T2,T3) ON P1(T1,T2) AND P2(T1,T3)
  WHERE P(T1,T2,T3)
```
一种是先验证T2，然后是T3
```sql
FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t2 in T2 such that P1(t1,t2) {
    FOR each row t3 in T3 such that P2(t1,t3) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f1:=TRUE
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
```
另一种是先T3，然后T2
```sql
FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t3 in T3 such that P2(t1,t3) {
    FOR each row t2 in T2 such that P1(t1,t2) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f1:=TRUE
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
```

当我们讨论内部连接的嵌套循环算法，我们忽略了一些可能对性能有巨大影响的细节。我们没有提到所谓的"下推"条件，假设条件P(T1,T2,T3)可以使用下面的连接表达式替代：
```SQL
P(T1,T2,T2) = C1(T1) AND C2(T2) AND C3(T3).
```

在这种情况下，MySQL实际上使用下面的嵌套循环算法来执行带有内部连接的查询
```sql
FOR each row t1 in T1 such that C1(t1) {
  FOR each row t2 in T2 such that P1(t1,t2) AND C2(t2)  {
    FOR each row t3 in T3 such that P2(t2,t3) AND C3(t3) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
```
 
您可以看到，每个连接点C1(T1)、C2(T2)、C3(T3)都被从最内环推出到可以对其进行计算的最外层环。如果C1(T1)是一个非常严格的条件，那么这个条件下推可能会大大减少表T1传递给内部循环的行数。因此，查询的执行时间可能会大大提高。

对于具有外部连接的查询，只有在发现外部表的当前行在内部表中有匹配时才检查WHERE条件。因此，从内部嵌套循环中下推条件的优化不能直接应用于具有外部连接的查询。在这里，我们必须引入条件下推谓词的标志位，以便遇到匹配时执行。

回想外连接的例子
```sql
P(T1,T2,T3)=C1(T1) AND C(T2) AND C3(T3)
```
在那个例子中，打开了下推条件标志位的嵌套循环算法会如下操作：
``` sql
FOR each row t1 in T1 such that C1(t1) {
  BOOL f1:=FALSE;
  FOR each row t2 in T2
      such that P1(t1,t2) AND (f1?C2(t2):TRUE) {
    BOOL f2:=FALSE;
    FOR each row t3 in T3
        such that P2(t2,t3) AND (f1&&f2?C3(t3):TRUE) {
      IF (f1&&f2?TRUE:(C2(t2) AND C3(t3))) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f2=TRUE;
      f1=TRUE;
    }
    IF (!f2) {
      IF (f1?TRUE:C2(t2) && P(t1,t2,NULL)) {
        t:=t1||t2||NULL; OUTPUT t;
      }
      f1=TRUE;
    }
  }
  IF (!f1 && P(t1,NULL,NULL)) {
      t:=t1||NULL||NULL; OUTPUT t;
  }
}
```
通常，下推谓词可以从连接条件(例如P1(T1,T2)和P(T2,T3))中提取.在这种情况下，下推谓词还由一个标志保护，该标志防止检查由相应的外连接操作生成的NUL补行的谓词。

在WHERE条件中使用谓词来进行内联表的索引访问传递是被禁止的。

## 8.2.1.9 外连接优化

外连接包括外右连接和左外连接

MySQL执行A外连接B会执行如下操作：

- 表B被设置为依赖于表A以及A所依赖的所有表
- 表A被设置为依赖于在左连接条件中使用的所有表(B除外)
- 左连接条件用于决定如何从表b中检索行(换句话说，不使用WHERE子句中的任何条件)
- 执行所有标准的连接优化，但一个表总是在它所依赖的所有表之后读取。如果存在循环依赖，则会发生错误
- 所有WHERE条件优化均可执行
- 如果有表A的一行匹配WHERE条件，但是表B没有一行匹配这个条件，则表B的所有列都被置为NULL
- 如果使用左连接，发现一些行并不存在于一些表中，可以进行如下测试：一列col_name声明为NOT NULL，但是WHERE条件中却是 WHERE col_name IS NULL。那么MySQL在找到一行匹配左连接条件以后将停止查找其他行数据(为了特殊的索引连接)

右连接类似于左连接的反向执行。右连接会转换为等价的左连接再执行，参考[Section 8.2.1.10, “Outer Join Simplification”.](https://dev.mysql.com/doc/refman/8.0/en/outer-join-simplification.html)

对于左连接，如果所生成的空行的WHERE条件始终为false，左连接转化为内连接。比如说，如果下面的查询中她.column1是NULL，那么WHERE条件将一直为false。
```sql
    SELECT * FROM t1 LEFT JOIN t2 ON (column1) WHERE t2.column2=5;
```

因此，转换为内连接是安全的：
```sql
    SELECT * FROM t1 LEFT JOIN t2 ON (column1) WHERE t2.column2=5;
```

在MySQL8.0.14以后，当连接条件满足后，WHERE条件的常量表达式会在准备阶段就被清除，而不是等到后面的优化接断。早点将无关紧要的条件清楚有利于优化器将外连接转换为内谅解，对于在WHERE子句中包含不必要条件的外部连接查询，这可以改进查询计划。比如说下面这个例子：
```sql
SELECT * FROM t1 LEFT JOIN t2 ON condition_1 WHERE condition_2 OR 0 = 1
```

比如说，优化器人为 0 = 1是一直为false，这个条件就是多余的，改进后的如下：
```sql
SELECT * FROM t1 LEFT JOIN t2 ON condition_1 where condition_2
```
现在优化器可以用内连接重写查询：
```sql
SELECT * FROM t1 JOIN t2 WHERE condition_1 AND condition_2
```

这样以来，优化器就可以在使用表1之前使用表2了，这样查询性能更佳。如果想对表连接的顺序做一个提示，使用优化器提示。参考[ Section 8.9.3, “Optimizer Hints”](https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html)。也可以使用 STRAIGHT_JOIN，参考[ Section 13.2.10, “SELECT Statement”](https://dev.mysql.com/doc/refman/8.0/en/select.html)。不过STRAIGHT_JOIN可能影响索引的使用，因为它禁止了半连接的转化，参考[Section 8.2.2.1, “Optimizing IN and EXISTS Subquery Predicates with Semijoin Transformations”.](https://dev.mysql.com/doc/refman/8.0/en/semijoins.html)


## 8.2.1.10 外连接简化

FROM表达式中表语句又多种简化方式。

在解析阶段，右连接查询被转换为等价的左连接查询。通常情况下，如下形式的右连接
```sql
(T1, ...) RIGHT JOIN (T2, ...) ON P(T1, ..., T2, ...)
```
被翻译成了等价的下面的左连接
```sql
(T2, ...) LEFT JOIN (T1, ...) ON P(T1, ..., T2, ...)
```

所有的内连接T1 INNER JOIN T2 ON P(T1,T2)被替换为T1,T2, P(T1,T2)连接在WHERE条件中(或者嵌套连接的条件，如果有的话)

当优化器评估外连接操作的执行计划时，只考虑外部表比内部表先访问的情况。优化器的选择有限制是因为只有这种情况下外连接可以使用嵌套循环算法。

考虑如下形式的查询，R(T2)大大减少了T2表的匹配行数
```sql
SELECT * T1 LEFT JOIN T2 ON P1(T1,T2)
  WHERE P(T1,T2) AND R(T2)
```
如果查询语句如所写的这样，那么优化器只有先访问限制更少的T1，而后访问T2，这样可能造成查询计划非常低效。

与此相反，MySQL将将查询转换为没有外连接的操作如果WHERE条件是null-rejected(即将外连接转换为内连接)。所谓的对外连接操作的null-rejected是对于生成的行所有条件都是FALSE或者是UNKOWN。

比如说：
```sql
T1 LEFT JOIN T2 ON T1.A=T2.A
```
这个条件是null-rejected因为对于所有NULL填充的行都不可能为真(T2的列被设置为NULL)。

```sql
T2.B IS NOT NULL
T2.B > 3
T2.C <= T1.C
T2.B < 2 OR T2.C > 1
```
这里的条件就不是null-rejected因为对于NULL填充的行可能为真。
```sql
T2.B IS NULL
T1.B < 3 OR T2.B IS NOT NULL
T1.B < 3 OR T2.B > 3
```

判断一个外连接的操作条件是不是null-rejected的总体原则很简单：

- A是内部表的属性，A的条件格式为 A IS NOT NULL
- 它是一个谓词，包含对内部表的引用，当其中一个参数为NULL时，该引用的计算结果为UNKNOWN
- 包含一个null-rejected的连接
- 它是null-rejected条件的分离

一个条件对于一个外连接可以是null-rejected，而对于另一个则可能不是。在这个查询中，WHERE条件对第一个外连接来说不是null-rejected，对于第二个则是
```sql
    SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 LEFT JOIN T3 ON T3.B=T1.B
    WHERE T3.C > 0
```

如果对于一个外连接操作，WHERE条件是null-rejected的，那么外连接将转换为内连接操作。

比如说，在前面的查询中，第二个外连接是null-rejected，可以如下转换为内连接
```sql
    SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                     INNER JOIN T3 ON T3.B=T1.B
    WHERE T3.C > 0
```

对于一个外连接操作的转换可能触发另一个转换，即如下的查询：
```sql
    SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 LEFT JOIN T3 ON T3.B=T2.B
    WHERE T3.C > 0
```
首先转换成这个查询:
```sql
    SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
             INNER JOIN T3 ON T3.B=T2.B
    WHERE T3.C > 0
```
等价于下面这个查询:
```sql
    SELECT * FROM (T1 LEFT JOIN T2 ON T2.A=T1.A), T3
    WHERE T3.C > 0 AND T3.B=T2.B
```
剩下的外连接，也可以被替换为内查询因为条件T3.B=T2.B是null-rejected。这就生成了如下完全没有外连接的查询：
```sql
SELECT * FROM (T1 INNER JOIN T2 ON T2.A=T1.A), T3
  WHERE T3.C > 0 AND T3.B=T2.B
```

又是优化器可以成功替换外连接查询，但是对于嵌套的外连接查询，如下所示:
```sql
SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A
  WHERE T3.C > 0
```
等价于：
```sql
SELECT * FROM T1 LEFT JOIN
              (T2 INNER JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A
  WHERE T3.C > 0
```
这个只能被重写为包含嵌套外连接操作的查询:
```sql
SELECT * FROM T1 LEFT JOIN
              (T2,T3)
              ON (T2.A=T1.A AND T3.B=T2.B)
  WHERE T3.C > 0
```

任何尝试转换嵌套的外连接查询必须考虑嵌套的外连接条件和WHERE条件。在下面这个查询中，WHERE条件不是null-rejected，但是嵌套的外连接的连接条件T2.A=T1.A AND T3.C=T1.C是null-rejected
```sql
SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A AND T3.C=T1.C
  WHERE T3.D > 0 OR T1.D > 0
```
因此，这个查询可以转换成：
```sql
SELECT * FROM T1 LEFT JOIN
              (T2, T3)
              ON T2.A=T1.A AND T3.C=T1.C AND T3.B=T2.B
  WHERE T3.D > 0 OR T1.D > 0
```

## 8.2.1.11 多范围读优化

当表较大且未存储在存储引擎的高速缓存中时，在辅助索引上使用范围扫描来读取行会导致对表的大量随机磁盘访问。通过磁盘扫描多范围读取（MRR）优化，MySQL试图通过首先扫描索引并收集相关行的键来减少范围扫描的随机磁盘访问数量。磁盘扫描MRR的动机是减少随机磁盘访问的次数，从而使得对基表数据进行更顺序的扫描。

多范围读取优化有以下优点：

- MRR使基于索引元组的数据行可以顺序访问，而不是以随机顺序访问。服务器获取一组满足查询条件的索引元组，并根据数据行ID顺序对它们进行排序，然后使用排序后的元组按顺序检索数据行。这使得数据访问更加高效且成本更低。
- 对于需要通过索引元组访问数据行的操作（例如范围索引扫描和使用索引作为联接属性的等联接）的操作，MRR支持对键访问请求的批处理。。MRR在一系列索引范围内进行迭代以获得合格的索引元组。随着这些结果的累积，它们将用于访问相应的数据行。在开始读取数据行之前不必获取所有索引元组。

InnoDB支持在生成的虚拟列上使用辅助索引，但是MRR优化并不支持。

下面的场景展示了MRR优化的用武之地：

方案A： MRR可用于InnoDB和 MyISAM索引范围扫描和表相等联接的操作。

1. 部分索引被缓存了；
2. 缓存中的索引按他们数据的行ID进行排序；
3. 数据行是通过排序的索引进行访问的。

场景B： MRR可以 NDB用于多范围索引扫描的表，或者在按属性执行等值联接时使用。

1. 一部分范围（可能是单键范围）累积在提交查询的中心节点上的缓冲区中。

2. 范围被发送到访问数据行的执行节点。

3. 被访问的行被打包到程序包中并发送回中心节点。

4. 收到的带有数据行的数据包将放置在缓冲区中。

5. 从缓冲区读取数据行。

使用MRR时Extra，EXPLAIN输出中的列 显示 Using MRR。

如果没有必要进行全表扫描产生查询结果，则InnoDB和MyISAM不使用MRR。即从索引即可获得查询结果(通过[covering index](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_covering_index))，这种情况下MRR就没有用处了。

两个[optimizer_switch](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_optimizer_switch)系统变量标志提供了使用MRR优化的接口。该[mrr](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html#optflag_mrr)标志控制是否启用MRR。如果标识位开启，则[mrr_cost_based](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html#optflag_mrr-cost-based)标识位控制了优化器在基于成本考虑来使用MRR(on)和不使用(off)。默认情况下，mrr标识位为on， mrr_const_base是on，参考[Section 8.9.2, “Switchable Optimizations”.](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html)。

对于MRR，存储引擎将[read_rnd_buffer_size](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_read_rnd_buffer_size)系统变量的值 用作可为其缓冲区分配多少内存的准则。引擎最多使用read_rnd_buffer_size字节，并确定要在一次通过中处理的范围数。

## 8.2.1.12 块嵌套循环和批量索引关联

在MySQL中，可以使用批处理索引访问（BKA）联接算法，该算法同时使用对联接表的索引访问和联接缓冲区。KA算法支持内部联接，外部联接和半联接操作，包括嵌套的外部联接。BKA的好处包括由于更高效的表扫描而提高了连接性能。此外，以前仅可用于内部联接的块嵌套循环（BNL）联接算法得到了扩展，可以用于外部联接和半联接操作，包括嵌套的外部联接。

以下各节讨论基于原始BNL算法，扩展的BNL算法和BKA算法的扩展的连接缓冲区管理。有关半联接策略的信息，请参见[Section 8.2.2.1, “Optimizing IN and EXISTS Subquery Predicates with Semijoin Transformations”](https://dev.mysql.com/doc/refman/8.0/en/semijoins.html)

- 用于块嵌套循环和批处理索引访问算法的联接缓冲区管理

- 外部联接和半联接的块嵌套循环算法

- 批量索引访问联接

- 块嵌套循环和批处理索引访问算法的优化器提示

### 用于块嵌套循环和批处理索引访问算法的联接缓冲区管理

MySQ不仅可以在不访问内部表时使用关联索引，也可以在子查询完成后的外联和半连接查询中。而且，连接缓存可以用在有索引在内联表的情况中。

在存储感兴趣的行列的值时，连接缓冲区管理代码可以更有效地利用连接缓冲区空间：如果行列的值为NULL，则不会在缓冲区中为行列分配额外的字节，并且分配的最小的大小是任意VARCHAR值的大小。

该代码支持两种类型的缓冲区：常规缓冲区和增量缓冲区。假设使用缓冲区B1来t1,t2表连接，使用缓冲区B2来保存t1，t2关联结果与t3的关联：

- 常规关联缓存包含每个关联操作的所有列。如果B2是一个常规的关联缓冲，则B2是从B1的行和t3表中符合条件的行组合而成
- 增量关联缓冲只包含第二个关联操作的列。如果B2是一个增量关联缓冲，则它只包含t3表中符合条件的列和B1中行的连接

增量关联缓冲通常是相对于前面的关联操作缓冲区操作，所以被关联的一定是常规关联缓存。在已有的例子中，用于缓存t1 t2表的缓冲区B1一定是一个常规关联缓存。

每一个增量缓冲只包含被关联表中相关的列。这些列与join操作的前一个查询关联结果的索引和并组成结果。多个在增量缓存中的行可以连接到之前的常规关联索引的同一行。

增量缓冲使得关联查询中前面的查询的拷贝频率降低。这有效减小了缓冲区的大小，因为join操作的前面的结果可能被后面的多次匹配到，这就减少了对join之前结果的多次拷贝。同样的，由于拷贝量减少，因而总的时间也会减少。

在MySQL8.0中， [https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_optimizer_switch](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_optimizer_switch)系统变量中的[block_nested_loop](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html#optflag_block-nested-loop)标志位是如下工作的：

- 在MySQL8.0.20以前，它控制了优化器是否使用块嵌套关联索引算法
- 在MySQL8.0.18以后，它也控制了对哈希关联的使用
- 在MySQL8.0.20以后，这个标识位只控制哈希关联，对块嵌套索引不再支持

[batched_key_access](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html#optflag_batched-key-access)标志位控制了优化器是否使用批量索引关联算法。

默认[block_nested_loop](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html#optflag_block-nested-loop)标志位是on，[batched_key_access](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html#optflag_batched-key-access)是off。参考[ Section 8.9.2, “Switchable Optimizations”](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html)。优化器提示也可以使用，参考[Optimizer Hints for Block Nested-Loop and Batched Key Access Algorithms.](https://dev.mysql.com/doc/refman/8.0/en/bnl-bka-optimization.html#bnl-bka-optimizer-hints)。

关于半连接的策略，可以参考[Section 8.2.2.1, “Optimizing IN and EXISTS Subquery Predicates with Semijoin Transformations”](https://dev.mysql.com/doc/refman/8.0/en/semijoins.html)来获取更多详细信息。

### 用于外连接和半连接的块嵌套循环算法

MySQL块嵌套循环算法(BNL)的原始实现是扩展了外连接和半连接操作(后面也被哈希关联算法所替代，参考[Section 8.2.1.4, “Hash Join Optimization”](https://dev.mysql.com/doc/refman/8.0/en/hash-joins.html)))

当这些操作使用关联缓存，放进缓存的每一行都有一个是否匹配的标志位。

如果outer join使用了关联缓存，那么join操作的另一边将逐行匹配在缓存中的行。如果找到了匹配的行，那么就合并形成新的行并且将结果给其他关联操作。此外，缓存中的行的匹配标志位开启。当被关联的表的所有行都被检查过以后，将扫描关联缓存。在关联缓存中的没有匹配标志位的将被设置位NULL填充(即join右边的列设置为NULL)，结果将传递给其他关联操作。

在MySQL8.0中， [https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_optimizer_switch](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_optimizer_switch)系统变量中的[block_nested_loop](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html#optflag_block-nested-loop)标志位是如下工作的：

- 在MySQL8.0.20以前，它控制了优化器是否使用块嵌套关联索引算法
- 在MySQL8.0.18以后，它也控制了对哈希关联的使用
- 在MySQL8.0.20以后，这个标识位只控制哈希关联，对块嵌套索引不再支持

参考[Section 8.9.2, “Switchable Optimizations”](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html)获取更多信息，优化器提示也可以使用，参考[Optimizer Hints for Block Nested-Loop and Batched Key Access Algorithms.](https://dev.mysql.com/doc/refman/8.0/en/bnl-bka-optimization.html#bnl-bka-optimizer-hints)。

使用BNL算法的表会在EXPLAIN输出中，在Extra列显示Using join buffer (Block Nested Loop)，类型为ALL, index, 或者 range。

关于半连接的策略，可以参考[Section 8.2.2.1, “Optimizing IN and EXISTS Subquery Predicates with Semijoin Transformations”](https://dev.mysql.com/doc/refman/8.0/en/semijoins.html)来获取更多详细信息。

### 批量索引访问关联

MySQL实现了一种表关联的方法，称为批量索引访问关联算法(BKA)。BKA可以在
