---
title: 8.2 优化SQL表达式
date: 2020-12-01
last-update: 2020-11-01
tags:
 - MySQL
keywords:
 - MySQL
 - manual
 - 优化
---


数据库应用程序的核心逻辑是通过SQL语句执行的，无论是直接通过解释器发出还是通过API在后台提交。本节中的调优指南有助于加速所有类型的MySQL应用程序。这些指导方针涵盖了读和写数据的SQL操作、SQL操作的一般幕后开销以及特定场景中使用的操作(如数据库监视)。

## 8.2.1 优化查询语句

查询以SELECT语句的形式执行数据库中的所有查找操作。调优这些语句是最重要的任务，无论是为动态web页面实现亚秒级的响应时间，还是减少生成大量夜间报告的时间。

除了SELECT语句之外，查询的调优技术也适用于诸 CREATE TABLE...AS SELECT, INSERT INTO...SELECT以及DELETE语句中的WHERE表达式。这些语句还有其他性能考虑因素，因为它们将写操作与面向读的查询操作结合在一起。

NDB集群支持一种下推式的优化通过将连接查询发到各个NDB节点中，以便可以分布式同步执行查询。更多详情请参阅[Conditions for NDB pushdown joins. ](https://dev.mysql.com/doc/refman/8.0/en/mysql-cluster-options-variables.html#ndb_join_pushdown-conditions)

优化查询的主要考虑事项是:

- 将一个SELECT ... WHERE查询变快，第一件事是查看是否可以添加索引。在WHERE子句中使用的列上设置索引，以加速结果的计算、筛选和最终检索。为了避免浪费磁盘空间，构造一个小的索引集来加速应用程序中使用的许多相关查询。
  
  索引对于使用联接和外键等功能引用不同表的查询尤为重要。可以使用[EXPLAIN](https://dev.mysql.com/doc/refman/8.0/en/explain.html)语句确定SELECT使用哪些索引。参照[Section 8.3.1, “How MySQL Uses Indexes” and Section 8.8.1, “Optimizing Queries with EXPLAIN”.](https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html)

- 隔离和调优查询的任何部分，例如函数调用，这会花费过多的时间。根据查询的结构，可以对结果集中的每一行调用一次函数，甚至对表中的每一行调用一次函数，这会极大地提高效率。
- 最小化查询中的全表扫描次数，特别是对于大表。
- 通过定期使用[ANALYZE TABLE](https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html)语句使表统计信息保持最新状态，因此优化器具有构造有效执行计划所需的信息。
- 了解每个表的存储引擎特定的调整技术，索引技术和配置参数。InnoDB和MyISAM都有一套指导原则来实现和保持查询的高性能。详情参考[Section 8.5.6, “Optimizing InnoDB Queries”](https://dev.mysql.com/doc/refman/8.0/en/optimizing-innodb-queries.html)和[SECTION 8.6.1 Optimizing MyISAM Queries](https://dev.mysql.com/doc/refman/8.0/en/optimizing-queries-myisam.html)
- 可以优化InnoDB表的单查询事务，参考[ Section 8.5.3, “Optimizing InnoDB Read-Only Transactions”](https://dev.mysql.com/doc/refman/8.0/en/innodb-performance-ro-txn.html)
- 避免以难以理解的方式转换查询，特别是在优化器自动执行某些相同转换的情况下。
- 如果性能问题不能通过基本准则之一轻松解决，那么通过阅读EXPLAIN计划并调整索引、WHERE子句、join子句等来研究特定查询的内部细节。(当你达到一定的专业水平时，阅读EXPLAIN计划可能是你解决每个问题的第一步)
- 调整MySQL用于缓存的内存区域的大小和属性。由于InnoDB缓冲池、MyISAM键缓存和MySQL查询缓存的有效使用，重复查询运行速度更快，因为结果是在第二次和后续时间从内存中检索的。
- 即使是使用缓存内存区域快速运行的查询，您仍然可以进一步优化，使它们需要更少的缓存内存，从而使您的应用程序更具可伸缩性。可伸缩性意味着您的应用程序可以处理更多的并发用户、更大的请求等等，而不会经历性能的大幅下降。
- 处理锁问题，在锁问题中，查询的速度可能会受到同时访问表的其他会话的影响。

### 8.2.1.1 WHERE语句优化
本节讨论可用于处理WHERE子句的优化。这些示例使用SELECT语句，但是DELETE和UPDATE语句中的WHERE子句也适用相同的优化。
::: tip
由于MySQL的优化在持续进行，这里并没有记录MySQL执行的所有优化。
:::
您可能会试图重写查询以提高算术运算速度，同时牺牲可读性。因为MySQL会自动进行类似的优化，所以通常可以避免这种工作，并使查询以一种更容易理解和维护的形式存在。下面是MySQL执行的一些优化:
- 去除不必要的括号
```sql
   ((a AND b) AND c OR (((a AND b) AND (c AND d))))
-> (a AND b AND c) OR (a AND b AND c AND d)
```
- 常数折叠
```sql
   (a<b AND b=c) AND a=5
-> b>5 AND b=c AND a=5
```
- 常数条件删除
```sql
   (b>=5 AND b=5) OR (b=6 AND 5=5) OR (b=7 AND 5=6)
-> b=5 OR b=6
```
在MySQL 8.0.14及以后版本中，这个过程发生在准备阶段，而不是优化阶段，这有助于简化连接。参考[Section 8.2.1.9, “Outer Join Optimization”](https://dev.mysql.com/doc/refman/8.0/en/outer-join-optimization.html)
- 索引使用的常量表达式只计算一次。
- 从MySQL 8.0.16开始，数值类型的列与常量值的比较将被检查、合并或删除无效或过期的值。参考[ Section 8.2.1.14, “Constant-Folding Optimization”](https://dev.mysql.com/doc/refman/8.0/en/constant-folding-optimization.html)
- 没有WHERE的单个表上的COUNT(*)直接从MyISAM表和内存表的表信息中检索。当只对一个表使用时，对于任何NOT NULL表达式也可以这样做。
- 对无效常量表达式的早期检测。MySQL能够迅速发现一些SELECT语句是无效的并且不返回任何数据。
- 如果不使用GROUP BY或聚合函数(COUNT()、MIN()等)，则使用WHERE合并HAVING。
- 对于在JOIN操作中的表，WHERE操作将构造得更简单以便速度更快，同时也尽早跳过行。
- 在查询中首先读取所有常量表，然后再读取其他表。常量表是以下任何一种
  * 空表或只有一行的表
  * 与主键或唯一索引上的WHERE子句一起使用的表，其中所有索引部分都与常量表达式进行比较，并定义为NOT NULL。
    下面所有的表都用作常量表
    ```sql
    SELECT * FROM t WHERE primary_key=1;
    SELECT * FROM t1,t2
        WHERE t1.primary_key=1 AND t2.primary_key=t1.id;
    ```
- 连接表的最佳连接组合是通过尝试所有可能找到的。如果ORDER BY和GROUP BY子句中的所有列都来自同一个表，则在连接时首选该表。
- 如果存在ORDER BY子句和不同的GROUP BY子句，或者ORDER BY或GROUP BY包含联接队列中第一个表以外的表中的列，则创建一个临时表。
- 如果使用SQL_SMALL_RESULT修饰符，MySQL将使用内存中的临时表。
- 每个表索引都会被查询，并且使用最好的索引，除非优化器认为使用全表扫描更有效。曾经，根据最佳索引是否跨越表的30%使用扫描，但是现在一个固定的百分比不再决定使用索引还是扫描。现在，优化器更加复杂，其估计基于其他因素，例如表大小，行数和I/O块大小。
- 在某些情况下，MySQL甚至可以不查阅数据文件就从索引中读取行。如果索引中使用的所有列都是数值型的，则仅使用索引树来解析查询。
- 在输出每一行之前，将跳过那些与HAVING子句不匹配的行。                                 

一些非常快的查询示例
```sql
SELECT COUNT(*) FROM tbl_name;

SELECT MIN(key_part1),MAX(key_part1) FROM tbl_name;

SELECT MAX(key_part2) FROM tbl_name
  WHERE key_part1=constant;

SELECT ... FROM tbl_name
  ORDER BY key_part1,key_part2,... LIMIT 10;

SELECT ... FROM tbl_name
  ORDER BY key_part1 DESC, key_part2 DESC, ... LIMIT 10;
```
MySQL只使用索引树解析以下查询，假设索引列是数字的
```sql
SELECT key_part1,key_part2 FROM tbl_name WHERE key_part1=val;

SELECT COUNT(*) FROM tbl_name
  WHERE key_part1=val1 AND key_part2=val2;

SELECT key_part2 FROM tbl_name GROUP BY key_part1;
```
下面的查询使用索引以排序顺序检索行，而不需要单独的排序通道
```sql
SELECT ... FROM tbl_name
  ORDER BY key_part1,key_part2,... ;

SELECT ... FROM tbl_name
  ORDER BY key_part1 DESC, key_part2 DESC, ... ;
```
### 8.2.1.2 范围优化
范围访问方法使用单个索引检索包含在一个或多个索引值区间内的表行子集。它可以用于单部分或多部分索引。下面几节描述优化器使用范围访问的条件。

#### 单值索引的范围查询
                       
对于单值，可以方便地用WHERE子句中的对应条件表示索引值区间，表示为范围条件，而不是区间。

单值索引范围条件的定义如下
- 对于BTREE和HASH索引，使用=, <=>, IN(), IS NULL,或者IS NOT NULL操作符与常量比较
- 此外，对于BTREE索引，使用 >, <, >=, <=, BETWEEN, !=,<> 操作符,或者不带通配符前缀的LIKE与常量比较
- 对于所有类型的索引，使用OR或者AND进行条件范围查询

这里的**常量**包含如下情况：
- 查询字符串中的常量
- 同一个JOIN中的[const](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_const)或者[system](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_system)表中的列
- 不关联的子查询的结果
- 完全由前面类型的子表达式组成的任何表达式

下面是一些在WHERE语句中使用范围查询的例子
```sql
SELECT * FROM t1
  WHERE key_col > 1
  AND key_col < 10;

SELECT * FROM t1
  WHERE key_col = 1
  OR key_col IN (15,18,20);

SELECT * FROM t1
  WHERE key_col LIKE 'ab%'
  OR key_col BETWEEN 'bar' AND 'foo';
```          

在优化器常量传播阶段，一些非常量值可能被转换为常量。

MySQL尝试在WHERE语句中为每个可能的索引抽取范围条件。在提取过程中，将删除不能用于构造范围条件的条件，组合产生重叠范围的条件，并删除产生空范围的条件。

看下面的表达式，key1是索引列，nokey没有索引:
```sql
SELECT * FROM t1 WHERE
  (key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
  (key1 < 'bar' AND nonkey = 4) OR
  (key1 < 'uux' AND key1 > 'z');
```
key1抽取的过程如下：
1  从原始的WHERE语句开始
```sql
(key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
(key1 < 'bar' AND nonkey = 4) OR
(key1 < 'uux' AND key1 > 'z')
```
2  首先剔除nokey = 4和key1 LIKE '%b'因为它们不能用于范围扫描。正确的去除方式是将这个语句变成TRUE，所以在范围扫描过程中我们不会错过任何匹配行。将相应语句替换为TRUE字段。
```sql
(key1 < 'abc' AND (key1 LIKE 'abcde%' OR TRUE)) OR
(key1 < 'bar' AND TRUE) OR
(key1 < 'uux' AND key1 > 'z')
```
3  总为真的条件转为TRUE，总为假的条件转为FALSE
- (key1 LIKE 'abcde%' OR TRUE) 总为真
- (key1 < 'uux' AND key1 > 'z') 总为假
将相应的条件转为常量字段
```sql
(key1 < 'abc' AND TRUE) OR (key1 < 'bar' AND TRUE) OR (FALSE)
```
将不必须的TRUE和FALSE字段删除
```sql
(key1 < 'abc') OR (key1 < 'bar')
```
4  将重叠的间隔组合成一个将产生用于范围扫描的最终条件
```sql
(key1 < 'bar')
```

一般而言(如上例中所展示的)，用于范围扫描的条件比WHERE子句的限制要小。MySQL执行额外的检查以过滤出满足range条件但不满足WHERE子句的行。

范围条件提取算法可以处理任意深度的嵌套AND / OR构造，并且其输出不依赖于条件在WHERE子句中出现的顺序。
               
MySQL不支持使用范围查询函数时将多个范围进行合并。为了突破这一限制，可以使用UNION来合并独立的SELECT语句，只是需要将不同的条件语句写在不同的SELECT中

#### 多值索引的范围查询

多值索引的条件查询是单值索引条件查询的扩展。多值索引的范围查询限制索引行在一个或者多个索引元组区间中。索引元组区间是定义在索引元组上并在索引上使用排序。

举例说明，考虑一个多指索引定义为key1(key_part1， key_part2, key_part3)，下列的key元组按索引顺序排列
```sql
key_part1  key_part2  key_part3
  NULL       1          'abc'
  NULL       1          'xyz'
  NULL       2          'foo'
   1         1          'abc'
   1         1          'xyz'
   1         2          'abc'
   2         1          'aaa'
```
条件key_part = 1定义了这个区间：
```sql
(1,-inf,-inf) <= (key_part1,key_part2,key_part3) < (1,+inf,+inf)
```
这个区间覆盖了第四，第五和第六个索引元组，可以使用区间范围查找函数

与此相反，条件key_part3 = 'abc'就没有定义一个单独的区间而不能使用区间范围查找函数

下面的描述详细描述了多值索引的工作方式

- 对于HASH索引，包含相同值的区间都可以被使用。这意味着以下形式的条件可以产生区间
```sql
    key_part1 cmp const1
AND key_part2 cmp const2
AND ...
AND key_partN cmp constN;
```
这里，const1, const2,...都是常量，cmp代表 =, <=>, 或者 IS NULL操作符中的一个，条件覆盖了所有的索引(即N个条件完全匹配索引中的N个字段)。比如说，下面是三部分HASH索引的范围条件：
```sql
key_part1 = 1 AND key_part2 IS NULL AND key_part3 = 'foo'
```
关于如何定义常量，已经在[Range Access Method for Single-Part Indexes.](https://dev.mysql.com/doc/refman/8.0/en/range-optimization.html#range-access-single-part)进行了说明。

- 对于BTREE索引，一个区间可以用在使用AND连接的多个条件中，每个条件将key的部分字段使用=, <=>, IS NULL, >, <, >=, <=, !=, <>, BETWEEN, 或者LIKE模式(模式不以通配符开头)的操作符与常量想比较。只要每个单独的索引都能匹配到条件，区间就是可用的(或者使用<>,!=划分的两个区间)。

当使用的操作符为=，<=>或者IS NULL时，优化器会尝试添加其他的索引部分。如果使用的是 >, <, >=, <=, !=, <>, BETWEEN, 或者 LIKE操作符，优化器则不考虑使用其他索引部分。在下面的表达式中，优化器会首先使用=进行第一次比较，接下来使用>=进行第二部分的比较，但是下来就不会使用索引的第三部分进行区间构造。
```sql
key_part1 = 'foo' AND key_part2 >= 10 AND key_part3 > 10
```
归一的区间是
```sql
('foo',10,-inf) < (key_part1,key_part2,key_part3) < ('foo',+inf,+inf)
```
可能创建的间隔包含的行比初始条件多。例如，前面的间隔包含不满足初始条件的值('foo'， 11,0)。

- 如果条件覆盖的各个子区间是用OR进行连接的，那么最终的区间将是这些区间的并集。如果是使用AND进行连接，那么最终区间是这些区间的交际，比如说，在下面的两部分索引的条件
```sql
(key_part1 = 1 AND key_part2 < 2) OR (key_part1 > 5)
```
最终区间是
```sql
(1,-inf) < (key_part1,key_part2) < (1,2)
(5,-inf) < (key_part1,key_part2)
```
在这个例子中，第一行的区间使用了一个索引的左边界范围和两个索引的右边界。在[EXPLAIN](https://dev.mysql.com/doc/refman/8.0/en/explain.html)的输出中可以看出使用到索引的最大前缀长度。

在一些案例中，key_len提示用到了索引的哪个部分，但是可能并不是你所期待的。假设key_part1和key_part2可以为NULL，那么key_len在如下场景中展示的则是两部分索引的长度：
```sql
key_part1 >= 1 AND key_part2 < 2
```
实际上这个条件会被转换为
```sql
key_part1 >= 1 AND key_part2 IS NOT NULL
```
有关如何执行优化以组合或消除单值索引上的范围条件的间隔的描述，参考[Range Access Method for Single-Part Indexes](https://dev.mysql.com/doc/refman/8.0/en/range-optimization.html#range-access-single-part)。对多部分指标的距离条件也执行类似的步骤。

#### 多值比较的等值范围优化

考虑如下表达式，col_name是一个索引列
```sql
col_name IN(val1, ..., valN)
col_name = val1 OR ... OR col_name = valN
```
如果col_name等于val1到valN之间的任何值，那表达式将为真。这些比较是等值范围比较(这个范围是一个单独的区间)。优化器会如下评估读匹配行和匹配范围
- 如果col_name上是一个unique索引，那么评估的范围是1因为最多只能有一行有用给定数据
- 如果在col_name上的是一个非unique索引，那么优化器在评估区间匹配的行数时需要深入索引和索引统计信息。

使用索引，优化器会使用范围末尾的值与范围区间内的行进行评估。比如说，表达式col_name IN(10,20,30)有三个等值范围，优化器会在每个范围进行两次下探进行行评估。成对的下探形成对行值的评估。

索引下探提供准确的行评估，但是随着比较次数的增加，优化器不在逐一进行行评估。使用索引的统计信息虽然准确度稍低，但是在大范围行评估的速度上会限制提升。

[eq_range_index_dive_limit](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_eq_range_index_dive_limit)系统变量允许你配置从索引行评估到索引统计信息分析的行数值。比如说，需要允许使用等值区间比较索引下探的最大行数是N，那么设置eq_range_index_dive_limit为N+1。如果需要禁用索引数据分析，直接设置eq_range_index_dive_limit为0.

更新表索引统计信息以获得最佳估计，使用[ANALYZE TABLE](https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html)

在MySQL8.0以前，除非设置了eq_range_index_dive_limit变量，没法跳过使用索引下探进行索引有效评估。在MySQL8.0，当满足如下所有条件时是可以做到的：
- 查询是单表查询，不需要连表
- 设置了单个索引的FORCE INDEX提示。其思想是，如果强制使用索引，那么执行对索引的下探的并没有其他额外开销。
- 索引不是非独立索引或者全文索引
- 没有子查询
- 没有使用DISTINCT, GROUP BY, 或者ORDER BY语句 

对于[EXPLAIN FOR CONNECTION](https://dev.mysql.com/doc/refman/8.0/en/explain.html),如果索引下探被跳过，那么输出的变化将如下所示：
- 对于传统的输出，rows和filtered值为NULL
- 对于JSON输出，rows_examined_per_scan和rows_produced_per_join不显示，skip_index_dive_due_to_force为true，消耗统计是不准确的

对于EXPLAIN输出而言，跳过索引下探并没有变化。

在执行查找哪个索引的下探被跳过了以后，在对应的[INFORMATION_SCHEMA.OPTIMIZER_TRACE](https://dev.mysql.com/doc/refman/8.0/en/information-schema-optimizer-trace-table.html)表中将包含一个 skipped_due_to_force_index值的index_dives_for_range_access字段。

#### 跳跃扫描范围查询函数

考虑到如下场景
```sql
CREATE TABLE t1 (f1 INT NOT NULL, f2 INT NOT NULL, PRIMARY KEY(f1, f2));
INSERT INTO t1 VALUES
  (1,1), (1,2), (1,3), (1,4), (1,5),
  (2,1), (2,2), (2,3), (2,4), (2,5);
INSERT INTO t1 SELECT f1, f2 + 5 FROM t1;
INSERT INTO t1 SELECT f1, f2 + 10 FROM t1;
INSERT INTO t1 SELECT f1, f2 + 20 FROM t1;
INSERT INTO t1 SELECT f1, f2 + 40 FROM t1;
ANALYZE TABLE t1;

EXPLAIN SELECT f1, f2 FROM t1 WHERE f2 > 40;
```


为了执行这个查询，MySQL可以选择一个索引扫描来获取所有的行(索引包括所有要选择的列)，然后应用WHERE子句中的f2 > 40条件来生成最终的结果集。

范围扫描比全索引扫描更有效，但不能在本例中使用，因为对于第一个索引列f1没有任何条件。然而，在MySQL 8.0.13中，优化器可以执行多个范围扫描，使用一种名为Skip Scan的方法对每个f1值执行一次扫描，该方法与松散索引扫描(Loose Index Scan)类似。具体参考[ Section 8.2.1.17, “GROUP BY Optimization”](https://dev.mysql.com/doc/refman/8.0/en/group-by-optimization.html):

1. 索引第一列f1上跳跃不同值;
2. 再在剩下的索引列上，为每一个不同的前缀值进行f2 > 40的子范围扫描。

为了充分展示前面所说的数据，算法会如下操作：

1. 获取索引列第一列的第一个去重值(f1 = 1)
2. 生成关于第一列的第一个去重值和第二列的扫描范围(f1 = 1 AND f2 > 40)
3. 执行范围扫描
4. 获取第一列的第二个去充值(f1 = 2)
5. 生成关于第一列的第二个去重值和第二列的扫描范围(f1 = 1 AND f2 > 40)
6. 执行范围扫描

使用此策略可以减少被访问的行数，因为MySQL跳过不符合每个构造范围的行。此跳过扫描访问方法适用于以下条件：

- 表T必须要至少有一个复合索引，索引形式形如([A_1, ..., A_k,] B_1, ..., B_m, C [, D_1, ..., D_n])。索引的A和D部分可以为空，但是B和C不可以。
- 查询只能涉及到一个表
- 查询不能使用GROUP BY或者DISTINCT
- 查询仅限于索引列
- 在A_1，... A_k上的比较方式必须是等值比较，被比较的值必须是常量，包括IN操作符
- 查询必须是一个连接查询，即使用AND和OR条件。(cond1(key_part1) OR cond2(key_part1)) AND (cond1(key_part2) OR ...) AND ...
- C列必须有范围条件
- D列上的条件是允许的，但是D列上的索引条件必须和C列组合

使用跳过扫描在EXPLAIN的输出显示如下:

- 使用索引跳过时在Extra列显示使用了嗽散索引跳跃扫描方法
- 如果索引可以用于跳跃扫描，索引应当出现在possible_keys列中

使用跳跃扫描，优化器可以通过"skip scan"元素以下面所列的形式进行追踪，则可以看到一个"best_skip_scan_summary"元素。
```sql
"skip_scan_range": {
  "type": "skip_scan",
  "index": index_used_for_skip_scan,
  "key_parts_used_for_access": [key_parts_used_for_access],
  "range": [range]
}
```

如果跳跃扫描被选作最好的范围扫描方式，则写入"chosen_range_access_summary"。如果跳跃扫描被选作最佳访问方式，

跳过扫描的使用取决于[optimizer_switch](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_optimizer_switch)优系统变量的w[skip_scan](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html#optflag_skip-scan)标志的值。参考[Section 8.9.2, “Switchable Optimizations”](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html)。默认标志为打开，可以通过设置skip_off来关闭。

除了通过optimizer_switch系统变量来在会话及级别控制跳跃扫描的控制优化器。支持在每条语句的基础上影响优化器的优化器提示，具体参考[ Section 8.9.3, “Optimizer Hints”](https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html)。

#### 行构造表达式的范围优化

优化器可以对一下形式的查询使用范围扫描访问方法
```sql
SELECT ... FROM t1 WHERE ( col_1, col_2 ) IN (( 'a', 'b' ), ( 'c', 'd' ));
```
而在此之前，需要将查询写成这种形式
```sql
SELECT ... FROM t1 WHERE ( col_1 = 'a' AND col_2 = 'b' )
OR ( col_1 = 'c' AND col_2 = 'd' );
```
优化器执行范围扫描的查询必须满足如下条件:

- 只能使用IN，而不能使用NOT IN
- 在IN表达式的左边，只能包含列
- 在IN表达式的右边，只能包含运行时的常量，或者是字面常量或者是在执行期间绑定到常量的本地列引用
- 在IN表达式的右边，多余一个行构造器

更多详细信息请参考[Section 8.2.1.22, “Row Constructor Expression Optimization”](https://dev.mysql.com/doc/refman/8.0/en/row-constructor-optimization.html)

#### 范围优化中的限制内存使用

为控制范围优化器可用的内存，使用[ range_optimizer_max_mem_size](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_range_optimizer_max_mem_size)系统变量:

- 值为0表示没有限制
- 如果值大于0，优化器将跟踪在考虑范围访问方法时所消耗的内存。如果即将超过指定的限制，则放弃范围访问方法，而考虑其他方法，包括全表扫描。如果发生这种情况，会出现以下警告(其中N是当前range_optimizer_max_mem_size值)
```sql
Warning    3170    Memory capacity of N bytes for
                   'range_optimizer_max_mem_size' exceeded. Range
                   optimization was not done for this query.
```  
- 对于UPDATE和DELETE语句，如果优化器失败回退到全表扫描，并且[sql_safe_updates](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_sql_safe_updates)系统变量已设置，则会产生一个错误而非一个警告。因为实际上，没有任何一个索引被用来判定那一行将被修改。详情参考[Using Safe-Updates Mode (--safe-updates).](https://dev.mysql.com/doc/refman/8.0/en/mysql-tips.html#safe-updates)

对于超出可用范围的单个查询，优化器会退回到不太优化的计划，这种情况下增加[range_optimizer_max_mem_size](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_range_optimizer_max_mem_size)可能有助于提升效率。

评估一个范围查找语句需要使用多少内存，使用如下指南
- 对于如下所示的简单查询，对于范围访问方法有一个候选索引，每个谓词与OR组合使用大约230字节
```sql
SELECT COUNT(*) FROM t
WHERE a=1 OR a=2 OR a=3 OR .. . a=N;
```

- 相似的，使用如下查询，每个使用AND进行连接则使用大约125字节

```sql
SELECT COUNT(*) FROM t
WHERE a=1 AND b=1 AND c=1 ... N;
```
- 对于使用IN查询
```sql
SELECT COUNT(*) FROM t
WHERE a IN (1,2, ..., M) AND b IN (1,2, ..., N);
```

在IN列表中的每个值都是用OR进行连接的。如果有两个列表，那么最终的数值数目就是两个列表数目的乘积。因此，这个使用OR进行连接的总数是M * N。

### 8.2.1.3 索引归并优化

索引归并访问方法检索具有多个范围扫描的行，并将它们的结果归并为一个。这种访问方法只合并来自单个表的索引扫描，而不是跨多个表的扫描。归并优化可以产生扫描部分的并集，交际，交集的并集。

索引合并到例子如下所示
```sql
SELECT * FROM tbl_name WHERE key1 = 10 OR key2 = 20;

SELECT * FROM tbl_name
  WHERE (key1 = 10 OR key2 = 20) AND non_key = 30;

SELECT * FROM t1, t2
  WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE 'value%')
  AND t2.key1 = t1.some_col;

SELECT * FROM t1, t2
  WHERE t1.key1 = 1
  AND (t2.key1 = t1.some_col OR t2.key2 = t1.some_col2);
```

::: tip 
索引优化算法有如下已知的限制
- 如果查询有一个复杂的WHERE字句，有多个AND/OR的嵌套，MySQL不会选择最优策略，尝试使用以下恒等转换
```sql
(x AND y) OR z => (x OR z) AND (y OR z)
(x OR y) AND z => (x AND z) OR (y AND z)
```
- 索引归并不能应用再全文索引上
:::

在EXPLAIN的输出钟，索引归并方法会在type列钟以index_merge的结果出现。在这种情况下，key这一列显示了使用到的索引，key_len包含了这些索引中的使用到的最长索引长度。

索引合并访问方法有多个算法，在EXPLAIN输出中的Extra列中显示
- Using intersect(...)
- Using union(...)
- Using sort_union(...)

下面的的部分将更详细得描述这些算法。优化器在索引合并优化方法和其他可选项中进行评估选择。

#### 索引归并交集访问算法

这种访问算法在WWHERE语句可以被转换成多个不同索引的合并，并且每个条件是以下几种情形之一的:

- 有N个如下形式的表达式，并且索引包含了所有字段，即索引被全覆盖了
```sql
key_part1 = const1 AND key_part2 = const2 ... AND key_partN = constN
```
- InnoDB表中主键上的任何范围条件
```sql
SELECT * FROM innodb_table
  WHERE primary_key < 10 AND key_col1 = 20;

SELECT * FROM tbl_name
  WHERE key1_part1 = 1 AND key1_part2 = 2 AND key2 = 2;
```
索引归并的交际算法对所有使用的索引执行同步扫描，并生成从合并索引扫描中接收到的行序列的交集。

如果所有的列都被索引覆盖，不会扫描全表(EXPLAIN输出中的Extra字段包含USING index)，下面是这种示例
```sql
SELECT COUNT(*) FROM t1 WHERE key1 = 1 AND key2 = 1;
```
如果所使用的索引未覆盖查询中的所有列，只有当满足所有已使用键的范围条件时，才扫描所有行。

如果其中一个归并条件是InnoDB表主键上的条件，那么它不用于行检索，而是用于过滤使用其他条件检索的行。

#### 索引归并的合并算法

这种条件的算法于上面的索引归并交集算法类似。不同的是使用OR进行各个条件连接，并且每个条件满足下述之一的:

- 有N个如下形式的表达式，并且索引包含了所有字段，即索引被全覆盖了
```sql
key_part1 = const1 OR key_part2 = const2 ... OR key_partN = constN
```
::: warning 译者注
源文中这里是使用AND连接的，实际上应该是OR
:::

- InnoDB表中主键上的任何范围条件
- 索引归并交集算法适用的
```sql
SELECT * FROM tbl_name
  WHERE key_col1 < 10 OR key_col2 < 20;

SELECT * FROM tbl_name
  WHERE (key_col1 > 10 OR key_col2 = 20) AND nonkey_col = 30;
```

#### 索引归并 排序-合并 访问算法

这种算法适用于所有范围条件使用OR进行连接，但是并不适用于索引归并的合并算法的

```sql
SELECT * FROM tbl_name
  WHERE key_col1 < 10 OR key_col2 < 20;

SELECT * FROM tbl_name
  WHERE (key_col1 > 10 OR key_col2 = 20) AND nonkey_col = 30;
```

索引归并排序-合并算法与索引归并合并算法的不同指出在于排序-合并必须先获取所有行的行ID，并且在返回任何行之前先排序。

#### 应用索引合并优化

索引归并是通过optimizer_switch系统变量中的index_merge, index_merge_intersection, index_merge_union, 和 index_merge_sort_union标识位所控制的。参考[Section 8.9.2, “Switchable Optimizations”](https://dev.mysql.com/doc/refman/8.0/en/switchable-optimizations.html)。默认情况下，这些标识位都是开启的。为了之开启某一个算法，将index_merge设置为off，并将要开启的算法标志位设置为on。

除了使用optimizer_switch系统变量进行索引归并算法会话级别的开启控制，MySQL也支持在pre-statment中使用关键字提示MySQL进行优化。参考[Section 8.9.3, “Optimizer Hints”. ](https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html)。

### 8.2.1.4 哈希连接优化

从MySQL8.0.18开始，MySQL连接条件上没有索引的相等连接，使用哈希连接。比如说:
```sql
SELECT *
    FROM t1
    JOIN t2
        ON t1.c1=t2.c1;
```
哈希连接也可以在单表判定中存在一个或者多个索引时使用。

散列连接通常比以前版本的MySQL中使用的块嵌套循环算法(请参阅[Block Nested-Loop Join Algorithm](https://dev.mysql.com/doc/refman/8.0/en/nested-loop-joins.html#block-nested-loop-join-algorithm))更快，而且目的也就是为了这种场景而使用。MySQL8.0.20自开始移除了对块钱套循环的支持，之前使用块嵌套循环的都使用哈希连接来实现。

在本节下面的例子中，我们假设t1,t2,t3表是使用如下建表语句构建的
```sql
CREATE TABLE t1 (c1 INT, c2 INT);
CREATE TABLE t2 (c1 INT, c2 INT);
CREATE TABLE t3 (c1 INT, c2 INT);
```
在使用了哈希连接的地方，EXLPAIN输出如下
```sql
mysql> EXPLAIN
    -> SELECT * FROM t1
    ->     JOIN t2 ON t1.c1=t2.c1\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: t2
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: Using where; Using join buffer (hash join)
```
(在MySQL8.0.20以前，必须要包含FORMAT=TREE选项，以查看给定连接是否使用散列连接)

[EXPLAIN ANALYZE](https://dev.mysql.com/doc/refman/8.0/en/explain.html#explain-analyze)也展示哈希连接的使用情况。

哈希连接也用于多表关联查询，只要在每对连接的表的连接条件中包含一个等值连接，比如说下面这个:
```sql
SELECT * FROM t1
    JOIN t2 ON (t1.c1 = t2.c1 AND t1.c2 < t2.c2)
    JOIN t3 ON (t2.c1 = t3.c1);
```
如上例所示使用了内连接，非等值关联条件会在等值关联完成以后应用为过滤器。(对于外连接，包括左连接，半连接，反连接，他们都被打印为连接的一部分。这些连接会在下面的示例中说明)这个在EXLAIN输出中可以看出。
```sql
mysql> EXPLAIN FORMAT=TREE
    -> SELECT *
    ->     FROM t1
    ->     JOIN t2
    ->         ON (t1.c1 = t2.c1 AND t1.c2 < t2.c2)
    ->     JOIN t3
    ->         ON (t2.c1 = t3.c1)\G
*************************** 1. row ***************************
EXPLAIN: -> Inner hash join (t3.c1 = t1.c1)  (cost=1.05 rows=1)
    -> Table scan on t3  (cost=0.35 rows=1)
    -> Hash
        -> Filter: (t1.c2 < t2.c2)  (cost=0.70 rows=1)
            -> Inner hash join (t2.c1 = t1.c1)  (cost=0.70 rows=1)
                -> Table scan on t2  (cost=0.35 rows=1)
                -> Hash
                    -> Table scan on t1  (cost=0.35 rows=1)
```

如上面的输出所示，多个哈希连接可以用于(也实际用于)夺标等值连接条件中。

在MySQL8.0.20前，哈希连接在每个连接表配对没有至少一个等值关联条件时无法使用，这时会使用较慢的块嵌套循环算法。在MySQL8.0.20以后，哈希连接也适用于之前不适用的场景，如下面所示：
```sql
mysql> EXPLAIN FORMAT=TREE
    -> SELECT * FROM t1
    ->     JOIN t2 ON (t1.c1 = t2.c1)
    ->     JOIN t3 ON (t2.c1 < t3.c1)\G
*************************** 1. row ***************************
EXPLAIN: -> Filter: (t1.c1 < t3.c1)  (cost=1.05 rows=1)
    -> Inner hash join (no condition)  (cost=1.05 rows=1)
        -> Table scan on t3  (cost=0.35 rows=1)
        -> Hash
            -> Inner hash join (t2.c1 = t1.c1)  (cost=0.70 rows=1)
                -> Table scan on t2  (cost=0.35 rows=1)
                -> Hash
                    -> Table scan on t1  (cost=0.35 rows=1)
```
(本节稍后将提供其他示例。)

哈希连接可以用于笛卡尔成绩，即没有特殊的连接条件，如下面的例子所示:
```sql
mysql> EXPLAIN FORMAT=TREE
    -> SELECT *
    ->     FROM t1
    ->     JOIN t2
    ->     WHERE t1.c2 > 50\G
*************************** 1. row ***************************
EXPLAIN: -> Inner hash join  (cost=0.70 rows=1)
    -> Table scan on t2  (cost=0.35 rows=1)
    -> Hash
        -> Filter: (t1.c2 > 50)  (cost=0.35 rows=1)
            -> Table scan on t1  (cost=0.35 rows=1)
```

在MySQL 8.0.20及以后版本中，不再需要包含至少一个等连接条件才能使用使用散列连接。这意味着下面的示例列表中都可以优化使用哈希连接:

-  内部非等值连接(Inner non-equi-join): 
```sql
mysql> EXPLAIN FORMAT=TREE SELECT * FROM t1 JOIN t2 ON t1.c1 < t2.c1\G
*************************** 1. row ***************************
EXPLAIN: -> Filter: (t1.c1 < t2.c1)  (cost=4.70 rows=12)
    -> Inner hash join (no condition)  (cost=4.70 rows=12)
        -> Table scan on t2  (cost=0.08 rows=6)
        -> Hash
            -> Table scan on t1  (cost=0.85 rows=6)
```
- Semijoin(半连接): 
```sql
mysql> EXPLAIN FORMAT=TREE SELECT * FROM t1 
    ->     WHERE t1.c1 IN (SELECT t2.c2 FROM t2)\G
*************************** 1. row ***************************
EXPLAIN: -> Nested loop inner join
    -> Filter: (t1.c1 is not null)  (cost=0.85 rows=6)
        -> Table scan on t1  (cost=0.85 rows=6)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (c2=t1.c1)
        -> Materialize with deduplication
            -> Filter: (t2.c2 is not null)  (cost=0.85 rows=6)
                -> Table scan on t2  (cost=0.85 rows=6)
```
- Antijoin(反连接)
```sql
mysql> EXPLAIN FORMAT=TREE SELECT * FROM t2 
    ->     WHERE NOT EXISTS (SELECT * FROM t1 WHERE t1.col1 = t2.col1)\G
*************************** 1. row ***************************
EXPLAIN: -> Nested loop antijoin
    -> Table scan on t2  (cost=0.85 rows=6)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (c1=t2.c1)
        -> Materialize with deduplication
            -> Filter: (t1.c1 is not null)  (cost=0.85 rows=6)
                -> Table scan on t1  (cost=0.85 rows=6)
```
- 左外连接(Left outer join):
```sql
mysql> EXPLAIN FORMAT=TREE SELECT * FROM t1 LEFT JOIN t2 ON t1.c1 = t2.c1\G
*************************** 1. row ***************************
EXPLAIN: -> Left hash join (t2.c1 = t1.c1)  (cost=3.99 rows=36)
    -> Table scan on t1  (cost=0.85 rows=6)
    -> Hash
        -> Table scan on t2  (cost=0.14 rows=6)
```
- 右外连接 (Right outer join 注意MySQL将所有右外连接都重写为左外连接)
```sql
mysql> EXPLAIN FORMAT=TREE SELECT * FROM t1 RIGHT JOIN t2 ON t1.c1 = t2.c1\G
*************************** 1. row ***************************
EXPLAIN: -> Left hash join (t1.c1 = t2.c1)  (cost=3.99 rows=36)
    -> Table scan on t2  (cost=0.85 rows=6)
    -> Hash
        -> Table scan on t1  (cost=0.14 rows=6)
```

在默认条件下，MySQL8.018以后在任何可能的情况下都使用哈希连接。可以通过控制使用［BNL］(https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-table-level)和NO_BNL优化器提示来使用或者禁用。

(MySQL 8.0.18支持 hash_join=on或 hash_join=off作为 optimizer_switch系统变量的设置的一部分，以及优化器提示HASH_JOIN或者NO_HASH_JOIN。在MySQL 8.0.19及以后版本中，这些不再有任何效果。)

哈希连接的内存使用可以使用[join_buffer_size](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_join_buffer_size)系统变量来控制;哈希连接不能使用超过此数量的内存。当哈希连接所需的内存超过可用内存时，MySQL通过使用磁盘上的文件来处理。如果发生这种情况，您应该知道，如果散列连接无法装入内存，并且创建的文件超过了设置的[open_files_limit](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_open_files_limit)，则连接可能不会成功。为了避免这种情况发生，可以尝试下面的改变方式:

- 增加join_buffer_size的大小，以便散列连接不会溢出到磁盘。
- 增加open_files_limit的大小

在MySQL8.0.10以后，哈希连接的连接缓冲区是递增分配的。因此，您可以将join_buffer_size设置得更高，而无需使用分配大量RAM的小查询，但是外部连接将分配整个缓冲区。在MySQL 8.0.20及以后版本中，散列连接也用于外连接(包括反连接和半连接)，因此这不再是一个问题。
