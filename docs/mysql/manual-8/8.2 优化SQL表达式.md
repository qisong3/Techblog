---
title: 8.2 优化SQL表达式
date: 2020-12-01
last-update: 2020-11-01
tags:
 - MySQL
keywords:
 - MySQL
 - manual
 - 优化
---


数据库应用程序的核心逻辑是通过SQL语句执行的，无论是直接通过解释器发出还是通过API在后台提交。本节中的调优指南有助于加速所有类型的MySQL应用程序。这些指导方针涵盖了读和写数据的SQL操作、SQL操作的一般幕后开销以及特定场景中使用的操作(如数据库监视)。

## 8.2.1 优化查询语句

查询以SELECT语句的形式执行数据库中的所有查找操作。调优这些语句是最重要的任务，无论是为动态web页面实现亚秒级的响应时间，还是减少生成大量夜间报告的时间。

除了SELECT语句之外，查询的调优技术也适用于诸 CREATE TABLE...AS SELECT, INSERT INTO...SELECT以及DELETE语句中的WHERE表达式。这些语句还有其他性能考虑因素，因为它们将写操作与面向读的查询操作结合在一起。

NDB集群支持一种下推式的优化通过将连接查询发到各个NDB节点中，以便可以分布式同步执行查询。更多详情请参阅[Conditions for NDB pushdown joins. ](https://dev.mysql.com/doc/refman/8.0/en/mysql-cluster-options-variables.html#ndb_join_pushdown-conditions)

优化查询的主要考虑事项是:

- 将一个SELECT ... WHERE查询变快，第一件事是查看是否可以添加索引。在WHERE子句中使用的列上设置索引，以加速结果的计算、筛选和最终检索。为了避免浪费磁盘空间，构造一个小的索引集来加速应用程序中使用的许多相关查询。
  
  索引对于使用联接和外键等功能引用不同表的查询尤为重要。可以使用[EXPLAIN](https://dev.mysql.com/doc/refman/8.0/en/explain.html)语句确定SELECT使用哪些索引。参照[Section 8.3.1, “How MySQL Uses Indexes” and Section 8.8.1, “Optimizing Queries with EXPLAIN”.](https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html)

- 隔离和调优查询的任何部分，例如函数调用，这会花费过多的时间。根据查询的结构，可以对结果集中的每一行调用一次函数，甚至对表中的每一行调用一次函数，这会极大地提高效率。
- 最小化查询中的全表扫描次数，特别是对于大表。
- 通过定期使用[ANALYZE TABLE](https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html)语句使表统计信息保持最新状态，因此优化器具有构造有效执行计划所需的信息。
- 了解每个表的存储引擎特定的调整技术，索引技术和配置参数。InnoDB和MyISAM都有一套指导原则来实现和保持查询的高性能。详情参考[Section 8.5.6, “Optimizing InnoDB Queries”](https://dev.mysql.com/doc/refman/8.0/en/optimizing-innodb-queries.html)和[SECTION 8.6.1 Optimizing MyISAM Queries](https://dev.mysql.com/doc/refman/8.0/en/optimizing-queries-myisam.html)
- 可以优化InnoDB表的单查询事务，参考[ Section 8.5.3, “Optimizing InnoDB Read-Only Transactions”](https://dev.mysql.com/doc/refman/8.0/en/innodb-performance-ro-txn.html)
- 避免以难以理解的方式转换查询，特别是在优化器自动执行某些相同转换的情况下。
- 如果性能问题不能通过基本准则之一轻松解决，那么通过阅读EXPLAIN计划并调整索引、WHERE子句、join子句等来研究特定查询的内部细节。(当你达到一定的专业水平时，阅读EXPLAIN计划可能是你解决每个问题的第一步)
- 调整MySQL用于缓存的内存区域的大小和属性。由于InnoDB缓冲池、MyISAM键缓存和MySQL查询缓存的有效使用，重复查询运行速度更快，因为结果是在第二次和后续时间从内存中检索的。
- 即使是使用缓存内存区域快速运行的查询，您仍然可以进一步优化，使它们需要更少的缓存内存，从而使您的应用程序更具可伸缩性。可伸缩性意味着您的应用程序可以处理更多的并发用户、更大的请求等等，而不会经历性能的大幅下降。
- 处理锁问题，在锁问题中，查询的速度可能会受到同时访问表的其他会话的影响。

### 8.2.1.1 WHERE语句优化
本节讨论可用于处理WHERE子句的优化。这些示例使用SELECT语句，但是DELETE和UPDATE语句中的WHERE子句也适用相同的优化。
::: tip
由于MySQL的优化在持续进行，这里并没有记录MySQL执行的所有优化。
:::
您可能会试图重写查询以提高算术运算速度，同时牺牲可读性。因为MySQL会自动进行类似的优化，所以通常可以避免这种工作，并使查询以一种更容易理解和维护的形式存在。下面是MySQL执行的一些优化:
- 去除不必要的括号
```sql
   ((a AND b) AND c OR (((a AND b) AND (c AND d))))
-> (a AND b AND c) OR (a AND b AND c AND d)
```
- 常数折叠
```sql
   (a<b AND b=c) AND a=5
-> b>5 AND b=c AND a=5
```
- 常数条件删除
```sql
   (b>=5 AND b=5) OR (b=6 AND 5=5) OR (b=7 AND 5=6)
-> b=5 OR b=6
```
在MySQL 8.0.14及以后版本中，这个过程发生在准备阶段，而不是优化阶段，这有助于简化连接。参考[Section 8.2.1.9, “Outer Join Optimization”](https://dev.mysql.com/doc/refman/8.0/en/outer-join-optimization.html)
- 索引使用的常量表达式只计算一次。
- 从MySQL 8.0.16开始，数值类型的列与常量值的比较将被检查、合并或删除无效或过期的值。参考[ Section 8.2.1.14, “Constant-Folding Optimization”](https://dev.mysql.com/doc/refman/8.0/en/constant-folding-optimization.html)
- 没有WHERE的单个表上的COUNT(*)直接从MyISAM表和内存表的表信息中检索。当只对一个表使用时，对于任何NOT NULL表达式也可以这样做。
- 对无效常量表达式的早期检测。MySQL能够迅速发现一些SELECT语句是无效的并且不返回任何数据。
- 如果不使用GROUP BY或聚合函数(COUNT()、MIN()等)，则使用WHERE合并HAVING。
- 对于在JOIN操作中的表，WHERE操作将构造得更简单以便速度更快，同时也尽早跳过行。
- 在查询中首先读取所有常量表，然后再读取其他表。常量表是以下任何一种
  * 空表或只有一行的表
  * 与主键或唯一索引上的WHERE子句一起使用的表，其中所有索引部分都与常量表达式进行比较，并定义为NOT NULL。
    下面所有的表都用作常量表
    ```sql
    SELECT * FROM t WHERE primary_key=1;
    SELECT * FROM t1,t2
        WHERE t1.primary_key=1 AND t2.primary_key=t1.id;
    ```
- 连接表的最佳连接组合是通过尝试所有可能找到的。如果ORDER BY和GROUP BY子句中的所有列都来自同一个表，则在连接时首选该表。
- 如果存在ORDER BY子句和不同的GROUP BY子句，或者ORDER BY或GROUP BY包含联接队列中第一个表以外的表中的列，则创建一个临时表。
- 如果使用SQL_SMALL_RESULT修饰符，MySQL将使用内存中的临时表。
- 每个表索引都会被查询，并且使用最好的索引，除非优化器认为使用全表扫描更有效。曾经，根据最佳索引是否跨越表的30%使用扫描，但是现在一个固定的百分比不再决定使用索引还是扫描。现在，优化器更加复杂，其估计基于其他因素，例如表大小，行数和I/O块大小。
- 在某些情况下，MySQL甚至可以不查阅数据文件就从索引中读取行。如果索引中使用的所有列都是数值型的，则仅使用索引树来解析查询。
- 在输出每一行之前，将跳过那些与HAVING子句不匹配的行。                                 

一些非常快的查询示例
```sql
SELECT COUNT(*) FROM tbl_name;

SELECT MIN(key_part1),MAX(key_part1) FROM tbl_name;

SELECT MAX(key_part2) FROM tbl_name
  WHERE key_part1=constant;

SELECT ... FROM tbl_name
  ORDER BY key_part1,key_part2,... LIMIT 10;

SELECT ... FROM tbl_name
  ORDER BY key_part1 DESC, key_part2 DESC, ... LIMIT 10;
```
MySQL只使用索引树解析以下查询，假设索引列是数字的
```sql
SELECT key_part1,key_part2 FROM tbl_name WHERE key_part1=val;

SELECT COUNT(*) FROM tbl_name
  WHERE key_part1=val1 AND key_part2=val2;

SELECT key_part2 FROM tbl_name GROUP BY key_part1;
```
下面的查询使用索引以排序顺序检索行，而不需要单独的排序通道
```sql
SELECT ... FROM tbl_name
  ORDER BY key_part1,key_part2,... ;

SELECT ... FROM tbl_name
  ORDER BY key_part1 DESC, key_part2 DESC, ... ;
```
### 8.2.1.2 范围优化
范围访问方法使用单个索引检索包含在一个或多个索引值区间内的表行子集。它可以用于单部分或多部分索引。下面几节描述优化器使用范围访问的条件。

#### 单值索引的范围查询
                       
对于单值，可以方便地用WHERE子句中的对应条件表示索引值区间，表示为范围条件，而不是区间。

单值索引范围条件的定义如下
- 对于BTREE和HASH索引，使用=, <=>, IN(), IS NULL,或者IS NOT NULL操作符与常量比较
- 此外，对于BTREE索引，使用 >, <, >=, <=, BETWEEN, !=,<> 操作符,或者不带通配符前缀的LIKE与常量比较
- 对于所有类型的索引，使用OR或者AND进行条件范围查询

这里的**常量**包含如下情况：
- 查询字符串中的常量
- 同一个JOIN中的[const](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_const)或者[system](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_system)表中的列
- 不关联的子查询的结果
- 完全由前面类型的子表达式组成的任何表达式

下面是一些在WHERE语句中使用范围查询的例子
```sql
SELECT * FROM t1
  WHERE key_col > 1
  AND key_col < 10;

SELECT * FROM t1
  WHERE key_col = 1
  OR key_col IN (15,18,20);

SELECT * FROM t1
  WHERE key_col LIKE 'ab%'
  OR key_col BETWEEN 'bar' AND 'foo';
```          

在优化器常量传播阶段，一些非常量值可能被转换为常量。

MySQL尝试在WHERE语句中为每个可能的索引抽取范围条件。在提取过程中，将删除不能用于构造范围条件的条件，组合产生重叠范围的条件，并删除产生空范围的条件。

看下面的表达式，key1是索引列，nokey没有索引:
```sql
SELECT * FROM t1 WHERE
  (key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
  (key1 < 'bar' AND nonkey = 4) OR
  (key1 < 'uux' AND key1 > 'z');
```
key1抽取的过程如下：
1  从原始的WHERE语句开始
```sql
(key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
(key1 < 'bar' AND nonkey = 4) OR
(key1 < 'uux' AND key1 > 'z')
```
2  首先剔除nokey = 4和key1 LIKE '%b'因为它们不能用于范围扫描。正确的去除方式是将这个语句变成TRUE，所以在范围扫描过程中我们不会错过任何匹配行。将相应语句替换为TRUE字段。
```sql
(key1 < 'abc' AND (key1 LIKE 'abcde%' OR TRUE)) OR
(key1 < 'bar' AND TRUE) OR
(key1 < 'uux' AND key1 > 'z')
```
3  总为真的条件转为TRUE，总为假的条件转为FALSE
- (key1 LIKE 'abcde%' OR TRUE) 总为真
- (key1 < 'uux' AND key1 > 'z') 总为假
将相应的条件转为常量字段
```sql
(key1 < 'abc' AND TRUE) OR (key1 < 'bar' AND TRUE) OR (FALSE)
```
将不必须的TRUE和FALSE字段删除
```sql
(key1 < 'abc') OR (key1 < 'bar')
```
4  将重叠的间隔组合成一个将产生用于范围扫描的最终条件
```sql
(key1 < 'bar')
```

一般而言(如上例中所展示的)，用于范围扫描的条件比WHERE子句的限制要小。MySQL执行额外的检查以过滤出满足range条件但不满足WHERE子句的行。

范围条件提取算法可以处理任意深度的嵌套AND / OR构造，并且其输出不依赖于条件在WHERE子句中出现的顺序。
               
MySQL不支持使用范围查询函数时将多个范围进行合并。为了突破这一限制，可以使用UNION来合并独立的SELECT语句，只是需要将不同的条件语句写在不同的SELECT中

#### 多值索引的范围查询

多值索引的条件查询是单值索引条件查询的扩展。多值索引的范围查询限制索引行在一个或者多个索引元组区间中。索引元组区间是定义在索引元组上并在索引上使用排序。

举例说明，考虑一个多指索引定义为key1(key_part1， key_part2, key_part3)，下列的key元组按索引顺序排列
```sql
key_part1  key_part2  key_part3
  NULL       1          'abc'
  NULL       1          'xyz'
  NULL       2          'foo'
   1         1          'abc'
   1         1          'xyz'
   1         2          'abc'
   2         1          'aaa'
```
条件key_part = 1定义了这个区间：
```sql
(1,-inf,-inf) <= (key_part1,key_part2,key_part3) < (1,+inf,+inf)
```
这个区间覆盖了第四，第五和第六个索引元组，可以使用区间范围查找函数

与此相反，条件key_part3 = 'abc'就没有定义一个单独的区间而不能使用区间范围查找函数

下面的描述详细描述了多值索引的工作方式

- 对于HASH索引，包含相同值的区间都可以被使用。这意味着以下形式的条件可以产生区间
```sql
    key_part1 cmp const1
AND key_part2 cmp const2
AND ...
AND key_partN cmp constN;
```
这里，const1, const2,...都是常量，cmp代表 =, <=>, 或者 IS NULL操作符中的一个，条件覆盖了所有的索引(即N个条件完全匹配索引中的N个字段)。比如说，下面是三部分HASH索引的范围条件：
```sql
key_part1 = 1 AND key_part2 IS NULL AND key_part3 = 'foo'
```
关于如何定义常量，已经在[Range Access Method for Single-Part Indexes.](https://dev.mysql.com/doc/refman/8.0/en/range-optimization.html#range-access-single-part)进行了说明。

- 对于BTREE索引，一个区间可以用在使用AND连接的多个条件中，每个条件将key的部分字段使用=, <=>, IS NULL, >, <, >=, <=, !=, <>, BETWEEN, 或者LIKE模式(模式不以通配符开头)的操作符与常量想比较。只要每个单独的索引都能匹配到条件，区间就是可用的(或者使用<>,!=划分的两个区间)。

当使用的操作符为=，<=>或者IS NULL时，优化器会尝试添加其他的索引部分。如果使用的是 >, <, >=, <=, !=, <>, BETWEEN, 或者 LIKE操作符，优化器则不考虑使用其他索引部分。在下面的表达式中，优化器会首先使用=进行第一次比较，接下来使用>=进行第二部分的比较，但是下来就不会使用索引的第三部分进行区间构造。
```sql
key_part1 = 'foo' AND key_part2 >= 10 AND key_part3 > 10
```
归一的区间是
```sql
('foo',10,-inf) < (key_part1,key_part2,key_part3) < ('foo',+inf,+inf)
```
可能创建的间隔包含的行比初始条件多。例如，前面的间隔包含不满足初始条件的值('foo'， 11,0)。

- 如果条件覆盖的各个子区间是用OR进行连接的，那么最终的区间将是这些区间的并集。如果是使用AND进行连接，那么最终区间是这些区间的交际，比如说，在下面的两部分索引的条件
```sql
(key_part1 = 1 AND key_part2 < 2) OR (key_part1 > 5)
```
最终区间是
```sql
(1,-inf) < (key_part1,key_part2) < (1,2)
(5,-inf) < (key_part1,key_part2)
```
在这个例子中，第一行的区间使用了一个索引的左边界范围和两个索引的右边界。在[EXPLAIN](https://dev.mysql.com/doc/refman/8.0/en/explain.html)的输出中可以看出使用到索引的最大前缀长度。

在一些案例中，key_len提示用到了索引的哪个部分，但是可能并不是你所期待的。假设key_part1和key_part2可以为NULL，那么key_len在如下场景中展示的则是两部分索引的长度：
```sql
key_part1 >= 1 AND key_part2 < 2
```
实际上这个条件会被转换为
```sql
key_part1 >= 1 AND key_part2 IS NOT NULL
```
有关如何执行优化以组合或消除单值索引上的范围条件的间隔的描述，参考[Range Access Method for Single-Part Indexes](https://dev.mysql.com/doc/refman/8.0/en/range-optimization.html#range-access-single-part)。对多部分指标的距离条件也执行类似的步骤。

#### 多值比较的等值范围优化

考虑如下表达式，col_name是一个索引列
```sql
col_name IN(val1, ..., valN)
col_name = val1 OR ... OR col_name = valN
```
如果col_name等于val1到valN之间的任何值，那表达式将为真。这些比较是等值范围比较(这个范围是一个单独的区间)。优化器会如下评估读匹配行和匹配范围
- 如果col_name上是一个unique索引，那么评估的范围是1因为最多只能有一行有用给定数据
- 如果在col_name上的是一个非unique索引，那么优化器在评估区间匹配的行数时需要深入索引和索引统计信息。

使用索引，优化器会使用范围末尾的值与范围区间内的行进行评估。比如说，表达式col_name IN(10,20,30)有三个等值范围，优化器会在每个范围进行两次下探进行行评估。成对的下探形成对行值的评估。

索引下探提供准确的行评估，但是随着比较次数的增加，优化器不在逐一进行行评估。使用索引的统计信息虽然准确度稍低，但是在大范围行评估的速度上会限制提升。

[eq_range_index_dive_limit](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_eq_range_index_dive_limit)系统变量允许你配置从索引行评估到索引统计信息分析的行数值。比如说，需要允许使用等值区间比较索引下探的最大行数是N，那么设置eq_range_index_dive_limit为N+1。如果需要禁用索引数据分析，直接设置eq_range_index_dive_limit为0.

更新表索引统计信息以获得最佳估计，使用[ANALYZE TABLE](https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html)

在MySQL8.0以前，除非设置了eq_range_index_dive_limit变量，没法跳过使用索引下探进行索引有效评估。在MySQL8.0，当满足如下所有条件时是可以做到的：
- 查询是单表查询，不需要连表
- 设置了单个索引的FORCE INDEX提示。其思想是，如果强制使用索引，那么执行对索引的下探的并没有其他额外开销。
- 索引不是非独立索引或者全文索引
- 没有子查询
- 没有使用DISTINCT, GROUP BY, 或者ORDER BY语句 

对于[EXPLAIN FOR CONNECTION](https://dev.mysql.com/doc/refman/8.0/en/explain.html),如果索引下探被跳过，那么输出的变化将如下所示：
- 对于传统的输出，rows和filtered值为NULL
- 对于JSON输出，rows_examined_per_scan和rows_produced_per_join不显示，skip_index_dive_due_to_force为true，消耗统计是不准确的

对于EXPLAIN输出而言，跳过索引下探并没有变化。

在执行查找哪个索引的下探被跳过了以后，在对应的[INFORMATION_SCHEMA.OPTIMIZER_TRACE](https://dev.mysql.com/doc/refman/8.0/en/information-schema-optimizer-trace-table.html)表中将包含一个 skipped_due_to_force_index值的index_dives_for_range_access字段。

#### 跳跃扫描范围查询函数

考虑到如下场景
```sql
CREATE TABLE t1 (f1 INT NOT NULL, f2 INT NOT NULL, PRIMARY KEY(f1, f2));
INSERT INTO t1 VALUES
  (1,1), (1,2), (1,3), (1,4), (1,5),
  (2,1), (2,2), (2,3), (2,4), (2,5);
INSERT INTO t1 SELECT f1, f2 + 5 FROM t1;
INSERT INTO t1 SELECT f1, f2 + 10 FROM t1;
INSERT INTO t1 SELECT f1, f2 + 20 FROM t1;
INSERT INTO t1 SELECT f1, f2 + 40 FROM t1;
ANALYZE TABLE t1;

EXPLAIN SELECT f1, f2 FROM t1 WHERE f2 > 40;
```


为了执行这个查询，MySQL可以选择一个索引扫描来获取所有的行(索引包括所有要选择的列)，然后应用WHERE子句中的f2 > 40条件来生成最终的结果集。

范围扫描比全索引扫描更有效，但不能在本例中使用，因为对于第一个索引列f1没有任何条件。然而，在MySQL 8.0.13中，优化器可以执行多个范围扫描，使用一种名为Skip Scan的方法对每个f1值执行一次扫描，该方法与松散索引扫描(Loose Index Scan)类似。具体参考[ Section 8.2.1.17, “GROUP BY Optimization”](https://dev.mysql.com/doc/refman/8.0/en/group-by-optimization.html):

1. 索引第一列f1上跳跃不同值;
2. 再在剩下的索引列上，为每一个不同的前缀值进行f2 > 40的子范围扫描。

为了充分展示前面所说的数据，算法会如下操作：

1. 获取索引列第一列的第一个去重值(f1 = 1)
2. 生成关于第一列的第一个去重值和第二列的扫描范围(f1 = 1 AND f2 > 40)
3. 执行范围扫描
4. 获取第一列的第二个去充值(f1 = 2)
5. 生成关于第一列的第二个去重值和第二列的扫描范围(f1 = 1 AND f2 > 40)
6. 执行范围扫描

使用此策略可以减少被访问的行数，因为MySQL跳过不符合每个构造范围的行。此跳过扫描访问方法适用于以下条件：

- 表T必须要至少有一个复合索引，索引形式形如([A_1, ..., A_k,] B_1, ..., B_m, C [, D_1, ..., D_n])。索引的A和D部分可以为空，但是B和C不可以。
- 查询只能涉及到一个表
- 查询不能使用GROUP BY或者DISTINCT
- 查询仅限于索引列
- 在A_1，... A_k上的比较方式必须是等值比较，被比较的值必须是常量，包括IN操作符
- 查询必须是一个连接查询，即使用AND和OR条件。(cond1(key_part1) OR cond2(key_part1)) AND (cond1(key_part2) OR ...) AND ...
- C列必须有范围条件
- D列上的条件是允许的，但是D列上的索引条件必须和C列组合

