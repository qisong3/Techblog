---
title: 8.2 优化SQL表达式
date: 2020-12-01
last-update: 2020-11-01
tags:
 - MySQL
keywords:
 - MySQL
 - manual
 - 优化
---


数据库应用程序的核心逻辑是通过SQL语句执行的，无论是直接通过解释器发出还是通过API在后台提交。本节中的调优指南有助于加速所有类型的MySQL应用程序。这些指导方针涵盖了读和写数据的SQL操作、SQL操作的一般幕后开销以及特定场景中使用的操作(如数据库监视)。

## 8.2.1 优化查询语句

查询以SELECT语句的形式执行数据库中的所有查找操作。调优这些语句是最重要的任务，无论是为动态web页面实现亚秒级的响应时间，还是减少生成大量夜间报告的时间。

除了SELECT语句之外，查询的调优技术也适用于诸 CREATE TABLE...AS SELECT, INSERT INTO...SELECT以及DELETE语句中的WHERE表达式。这些语句还有其他性能考虑因素，因为它们将写操作与面向读的查询操作结合在一起。

NDB集群支持一种下推式的优化通过将连接查询发到各个NDB节点中，以便可以分布式同步执行查询。更多详情请参阅[Conditions for NDB pushdown joins. ](https://dev.mysql.com/doc/refman/8.0/en/mysql-cluster-options-variables.html#ndb_join_pushdown-conditions)

优化查询的主要考虑事项是:

- 将一个SELECT ... WHERE查询变快，第一件事是查看是否可以添加索引。在WHERE子句中使用的列上设置索引，以加速结果的计算、筛选和最终检索。为了避免浪费磁盘空间，构造一个小的索引集来加速应用程序中使用的许多相关查询。
  
  索引对于使用联接和外键等功能引用不同表的查询尤为重要。可以使用[EXPLAIN](https://dev.mysql.com/doc/refman/8.0/en/explain.html)语句确定SELECT使用哪些索引。参照[Section 8.3.1, “How MySQL Uses Indexes” and Section 8.8.1, “Optimizing Queries with EXPLAIN”.](https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html)

- 隔离和调优查询的任何部分，例如函数调用，这会花费过多的时间。根据查询的结构，可以对结果集中的每一行调用一次函数，甚至对表中的每一行调用一次函数，这会极大地提高效率。
- 最小化查询中的全表扫描次数，特别是对于大表。
- 通过定期使用[ANALYZE TABLE](https://dev.mysql.com/doc/refman/8.0/en/analyze-table.html)语句使表统计信息保持最新状态，因此优化器具有构造有效执行计划所需的信息。
- 了解每个表的存储引擎特定的调整技术，索引技术和配置参数。InnoDB和MyISAM都有一套指导原则来实现和保持查询的高性能。详情参考[Section 8.5.6, “Optimizing InnoDB Queries”](https://dev.mysql.com/doc/refman/8.0/en/optimizing-innodb-queries.html)和[SECTION 8.6.1 Optimizing MyISAM Queries](https://dev.mysql.com/doc/refman/8.0/en/optimizing-queries-myisam.html)
- 可以优化InnoDB表的单查询事务，参考[ Section 8.5.3, “Optimizing InnoDB Read-Only Transactions”](https://dev.mysql.com/doc/refman/8.0/en/innodb-performance-ro-txn.html)
- 避免以难以理解的方式转换查询，特别是在优化器自动执行某些相同转换的情况下。
- 如果性能问题不能通过基本准则之一轻松解决，那么通过阅读EXPLAIN计划并调整索引、WHERE子句、join子句等来研究特定查询的内部细节。(当你达到一定的专业水平时，阅读EXPLAIN计划可能是你解决每个问题的第一步)
- 调整MySQL用于缓存的内存区域的大小和属性。由于InnoDB缓冲池、MyISAM键缓存和MySQL查询缓存的有效使用，重复查询运行速度更快，因为结果是在第二次和后续时间从内存中检索的。
- 即使是使用缓存内存区域快速运行的查询，您仍然可以进一步优化，使它们需要更少的缓存内存，从而使您的应用程序更具可伸缩性。可伸缩性意味着您的应用程序可以处理更多的并发用户、更大的请求等等，而不会经历性能的大幅下降。
- 处理锁问题，在锁问题中，查询的速度可能会受到同时访问表的其他会话的影响。

### 8.2.1.1 WHERE语句优化
本节讨论可用于处理WHERE子句的优化。这些示例使用SELECT语句，但是DELETE和UPDATE语句中的WHERE子句也适用相同的优化。
::: tip
由于MySQL的优化在持续进行，这里并没有记录MySQL执行的所有优化。
:::
您可能会试图重写查询以提高算术运算速度，同时牺牲可读性。因为MySQL会自动进行类似的优化，所以通常可以避免这种工作，并使查询以一种更容易理解和维护的形式存在。下面是MySQL执行的一些优化:
- 去除不必要的括号
```sql
   ((a AND b) AND c OR (((a AND b) AND (c AND d))))
-> (a AND b AND c) OR (a AND b AND c AND d)
```
- 常数折叠
```sql
   (a<b AND b=c) AND a=5
-> b>5 AND b=c AND a=5
```
- 常数条件删除
```sql
   (b>=5 AND b=5) OR (b=6 AND 5=5) OR (b=7 AND 5=6)
-> b=5 OR b=6
```
在MySQL 8.0.14及以后版本中，这个过程发生在准备阶段，而不是优化阶段，这有助于简化连接。参考[Section 8.2.1.9, “Outer Join Optimization”](https://dev.mysql.com/doc/refman/8.0/en/outer-join-optimization.html)
- 索引使用的常量表达式只计算一次。
- 从MySQL 8.0.16开始，数值类型的列与常量值的比较将被检查、合并或删除无效或过期的值。参考[ Section 8.2.1.14, “Constant-Folding Optimization”](https://dev.mysql.com/doc/refman/8.0/en/constant-folding-optimization.html)
- 没有WHERE的单个表上的COUNT(*)直接从MyISAM表和内存表的表信息中检索。当只对一个表使用时，对于任何NOT NULL表达式也可以这样做。
- 对无效常量表达式的早期检测。MySQL能够迅速发现一些SELECT语句是无效的并且不返回任何数据。
- 如果不使用GROUP BY或聚合函数(COUNT()、MIN()等)，则使用WHERE合并HAVING。
- 对于在JOIN操作中的表，WHERE操作将构造得更简单以便速度更快，同时也尽早跳过行。
- 在查询中首先读取所有常量表，然后再读取其他表。常量表是以下任何一种
  * 空表或只有一行的表
  * 与主键或唯一索引上的WHERE子句一起使用的表，其中所有索引部分都与常量表达式进行比较，并定义为NOT NULL。
    下面所有的表都用作常量表
    ```sql
    SELECT * FROM t WHERE primary_key=1;
    SELECT * FROM t1,t2
        WHERE t1.primary_key=1 AND t2.primary_key=t1.id;
    ```
- 连接表的最佳连接组合是通过尝试所有可能找到的。如果ORDER BY和GROUP BY子句中的所有列都来自同一个表，则在连接时首选该表。
- 如果存在ORDER BY子句和不同的GROUP BY子句，或者ORDER BY或GROUP BY包含联接队列中第一个表以外的表中的列，则创建一个临时表。
- 如果使用SQL_SMALL_RESULT修饰符，MySQL将使用内存中的临时表。
- 每个表索引都会被查询，并且使用最好的索引，除非优化器认为使用全表扫描更有效。曾经，根据最佳索引是否跨越表的30%使用扫描，但是现在一个固定的百分比不再决定使用索引还是扫描。现在，优化器更加复杂，其估计基于其他因素，例如表大小，行数和I/O块大小。
- 在某些情况下，MySQL甚至可以不查阅数据文件就从索引中读取行。如果索引中使用的所有列都是数值型的，则仅使用索引树来解析查询。
- 在输出每一行之前，将跳过那些与HAVING子句不匹配的行。                                 

一些非常快的查询示例
```sql
SELECT COUNT(*) FROM tbl_name;

SELECT MIN(key_part1),MAX(key_part1) FROM tbl_name;

SELECT MAX(key_part2) FROM tbl_name
  WHERE key_part1=constant;

SELECT ... FROM tbl_name
  ORDER BY key_part1,key_part2,... LIMIT 10;

SELECT ... FROM tbl_name
  ORDER BY key_part1 DESC, key_part2 DESC, ... LIMIT 10;
```
MySQL只使用索引树解析以下查询，假设索引列是数字的
```sql
SELECT key_part1,key_part2 FROM tbl_name WHERE key_part1=val;

SELECT COUNT(*) FROM tbl_name
  WHERE key_part1=val1 AND key_part2=val2;

SELECT key_part2 FROM tbl_name GROUP BY key_part1;
```
下面的查询使用索引以排序顺序检索行，而不需要单独的排序通道
```sql
SELECT ... FROM tbl_name
  ORDER BY key_part1,key_part2,... ;

SELECT ... FROM tbl_name
  ORDER BY key_part1 DESC, key_part2 DESC, ... ;
```
### 8.2.1.2 范围优化
范围访问方法使用单个索引检索包含在一个或多个索引值区间内的表行子集。它可以用于单部分或多部分索引。下面几节描述优化器使用范围访问的条件。

#### 单值索引的范围查询
                       
对于单值，可以方便地用WHERE子句中的对应条件表示索引值区间，表示为范围条件，而不是区间。

单值索引范围条件的定义如下
- 对于BTREE和HASH索引，使用=, <=>, IN(), IS NULL,或者IS NOT NULL操作符与常量比较
- 此外，对于BTREE索引，使用 >, <, >=, <=, BETWEEN, !=,<> 操作符,或者不带通配符前缀的LIKE与常量比较
- 对于所有类型的索引，使用OR或者AND进行条件范围查询

这里的**常量**包含如下情况：
- 查询字符串中的常量
- 同一个JOIN中的[const](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_const)或者[system](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_system)表中的列
- 不关联的子查询的结果
- 完全由前面类型的子表达式组成的任何表达式
 
                                  

