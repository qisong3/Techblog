---
title: 41. 缺失的第一个正数
date: 2021-02-21
last-update: 2021-02-21
tags:
 - 链表
keywords:
 - leetdode
---

## 题设

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

 

进阶：你可以实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案吗？

 

示例 1：

输入：nums = [1,2,0]
输出：3

示例 2：

输入：nums = [3,4,-1,1]
输出：2

示例 3：

输入：nums = [7,8,9,11,12]
输出：1

 

提示：

    0 <= nums.length <= 300
    -231 <= nums[i] <= 231 - 1

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/first-missing-positive
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 思路一 

如果本题没有额外的时空复杂度要求，那么就很容易实现：

- 我们可以将数组所有的数放入哈希表，随后从 111 开始依次枚举正整数，并判断其是否在哈希表中；

- 我们可以从 111 开始依次枚举正整数，并遍历数组，判断其是否在数组中。

如果数组的长度为 NNN，那么第一种做法的时间复杂度为 O(N)，空间复杂度为 O(N)；第二种做法的时间复杂度为 O(N2)，空间复杂度为 O(1)。但它们都不满足时间复杂度为 O(N) 且空间复杂度为 O(1)。

「真正」满足时间复杂度为 O(N) 且空间复杂度为 O(1) 的算法是不存在的，但是我们可以退而求其次：利用给定数组中的空间来存储一些状态。也就是说，如果题目给定的数组是不可修改的，那么就不存在满足时空复杂度要求的算法；但如果我们可以修改给定的数组，那么是存在满足要求的算法的。

满足条件的数组为 arr[0] = 1，arr[1] = 2，arr[2] = 3，arr[3] = 4，arr[4] = 5, 即a[i] = i + 1即为每个位子的数都是下标加一。

那么，我们可以将属于该位置的数组的数挪到该位置上，剩下的空缺的即为缺失的数。

```java
  
       class Solution {
           public int firstMissingPositive(int[] nums) {
               int len = nums.length;
               for (int i = 0; i < len; i++) {
                   // 小于0和大于len的肯定是不需要的数，并且对于同一位置已经放置了正确数值的，不需要重新放置
                   while (nums[i] > 0 && nums[i] <= len && nums[nums[i] - 1] != nums[i]) {
                       int temp = nums[nums[i] - 1];
                       nums[nums[i] - 1] = nums[i];
                       nums[i] = temp;
                   }
       
               }
               // 一遍循环可查
               for (int i = 0; i < len; i++) {
                   if (nums[i] != i + 1) {
                       return i + 1;
                   }
               }
               return len + 1;
           }
       }

```
- **时间复杂度** O(n^2)
- **空间复杂度** O(1)


